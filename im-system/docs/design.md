# IMç³»ç»Ÿå®Œæ•´è®¾è®¡æ–‡æ¡£ï¼šä»å…¥é—¨åˆ°ç”Ÿäº§çº§å®ç°

> æœ¬æ–‡æ¡£ç”±åŸºç¡€æ–¹æ¡ˆ(blog.md)å’ŒåŠŸèƒ½è¡¥å……è®¾è®¡(design_supplement.md)åˆå¹¶è€Œæˆï¼Œæ¶µç›–æ¶æ„è®¾è®¡ã€æ–¹æ¡ˆé€‰å‹ã€åŠŸèƒ½å®ç°å…¨æµç¨‹ã€‚

---

## ğŸ“š å®Œæ•´ç›®å½•

### ç¬¬ä¸€éƒ¨åˆ†ï¼šåŸºç¡€æ–¹æ¡ˆï¼ˆåƒäººåœ¨çº¿è½»é‡çº§å®ç°ï¼‰
- [å‰è¨€](#å‰è¨€)
- [ä¸€ã€æ¶æ„è®¾è®¡](#ä¸€æ¶æ„è®¾è®¡)
- [äºŒã€æŠ€æœ¯é€‰å‹](#äºŒæŠ€æœ¯é€‰å‹)
- [ä¸‰ã€æ ¸å¿ƒå®ç°ä»£ç ](#ä¸‰æ ¸å¿ƒå®ç°ä»£ç )
- [å››ã€éƒ¨ç½²æ–¹æ¡ˆ](#å››éƒ¨ç½²æ–¹æ¡ˆ)
- [äº”ã€æ‰©å±•ä¸ä¼˜åŒ–](#äº”æ‰©å±•ä¸ä¼˜åŒ–)
- [å…­ã€æ€»ç»“](#å…­æ€»ç»“)

### ç¬¬äºŒéƒ¨åˆ†ï¼šåŠŸèƒ½è¡¥å……è®¾è®¡ï¼ˆç”Ÿäº§çº§å®Œæ•´å®ç°ï¼‰
- [ä¸€ã€IMæ–¹æ¡ˆé€‰å‹å¯¹æ¯”](#ä¸€imæ–¹æ¡ˆé€‰å‹å¯¹æ¯”) - äº‘æœåŠ¡ vs å¼€æº vs è‡ªç ”
- [äºŒã€é€šä¿¡åè®®å¯¹æ¯”åˆ†æ](#äºŒé€šä¿¡åè®®å¯¹æ¯”åˆ†æ) - SSE vs WebSocket vs TCP
- [ä¸‰ã€å¼€æºIMé¡¹ç›®å¯¹æ¯”](#ä¸‰å¼€æºimé¡¹ç›®å¯¹æ¯”) - OpenIM/WuKongIM/Rocket.Chat
- [å››ã€æ¶ˆæ¯åè®®æ‰©å±•](#å››æ¶ˆæ¯åè®®æ‰©å±•)
- [äº”ã€ç¾¤ç»„ç®¡ç†ç³»ç»Ÿ](#äº”ç¾¤ç»„ç®¡ç†ç³»ç»Ÿ) - åŠ å…¥/é€€å‡º/è¸¢äºº/ç®¡ç†å‘˜
- [å…­ã€ç¦»çº¿æ¶ˆæ¯ä¸æ¨é€](#å…­ç¦»çº¿æ¶ˆæ¯ä¸æ¨é€) - APNs/FCMé›†æˆ
- [ä¸ƒã€æ¶ˆæ¯å¢å¼ºåŠŸèƒ½](#ä¸ƒæ¶ˆæ¯å¢å¼ºåŠŸèƒ½) - å·²è¯»å›æ‰§/æ’¤å›/ACK
- [å…«ã€æ–‡ä»¶æ¶ˆæ¯æ”¯æŒ](#å…«æ–‡ä»¶æ¶ˆæ¯æ”¯æŒ) - å›¾ç‰‡/æ–‡æ¡£/è§†é¢‘
- [ä¹ã€è·¨èŠ‚ç‚¹æ¶ˆæ¯è·¯ç”±](#ä¹è·¨èŠ‚ç‚¹æ¶ˆæ¯è·¯ç”±)
- [åã€å­˜å‚¨è®¾è®¡](#åå­˜å‚¨è®¾è®¡) - MySQLè¡¨ç»“æ„/Redisæ•°æ®ç»“æ„
- [åä¸€ã€å®Œæ•´é¡¹ç›®ç»“æ„](#åä¸€å®Œæ•´é¡¹ç›®ç»“æ„)
- [åäºŒã€åŠŸèƒ½å¯¹æ¯”æ€»ç»“](#åäºŒåŠŸèƒ½å¯¹æ¯”æ€»ç»“)
- [åä¸‰ã€ä¸‹ä¸€æ­¥å»ºè®®](#åä¸‰ä¸‹ä¸€æ­¥å»ºè®®)

---

# ç¬¬ä¸€éƒ¨åˆ†ï¼šåŸºç¡€æ–¹æ¡ˆ

# è‡ªåˆ¶IMç³»ç»Ÿï¼šåƒäººåŒæ—¶åœ¨çº¿æ‹¿æ¥å°±ç”¨

## å‰è¨€

å³æ—¶é€šè®¯(IM)ç³»ç»Ÿæ˜¯ç°ä»£åº”ç”¨çš„æ ‡é…ã€‚å¸‚é¢ä¸Šè™½æœ‰ä¼—å¤šIMäº‘æœåŠ¡ï¼Œä½†æ•°æ®å®‰å…¨ã€å®šåˆ¶éœ€æ±‚å’Œæˆæœ¬è€ƒè™‘è®©è‡ªç ”IMæˆä¸ºå¾ˆå¤šå›¢é˜Ÿçš„é€‰æ‹©ã€‚æœ¬æ–‡å°†ä»‹ç»ä¸€ä¸ªæ”¯æŒ**åƒäººåŒæ—¶åœ¨çº¿**çš„è½»é‡çº§IMç³»ç»Ÿæ¶æ„ï¼Œç‰¹ç‚¹æ˜¯**ç®€å•å¯è¿è¡Œã€æ‹¿æ¥å°±èƒ½ç”¨**ã€‚

## ä¸€ã€æ¶æ„è®¾è®¡

### 1.1 ç³»ç»Ÿåˆ†å±‚

é’ˆå¯¹åƒäººè§„æ¨¡ï¼Œæˆ‘ä»¬é‡‡ç”¨**ç®€åŒ–ç‰ˆä¸‰å±‚æ¶æ„**ï¼Œé¿å…è¿‡åº¦è®¾è®¡ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               å®¢æˆ·ç«¯å±‚                   â”‚
â”‚  (Web/iOS/Android/æ¡Œé¢åº”ç”¨)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ¥å…¥å±‚(Gateway)            â”‚
â”‚  - é•¿è¿æ¥ç®¡ç†(WebSocket)               â”‚
â”‚  - æ¶ˆæ¯æ”¶å‘ä¸è·¯ç”±                      â”‚
â”‚  - ç”¨æˆ·ä¼šè¯ç®¡ç†                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              é€»è¾‘å±‚(Service)            â”‚
â”‚  - ä¸šåŠ¡é€»è¾‘å¤„ç†                        â”‚
â”‚  - æ¶ˆæ¯æŒä¹…åŒ–                          â”‚
â”‚  - ç”¨æˆ·/ç¾¤ç»„ç®¡ç†                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å­˜å‚¨å±‚(Store)              â”‚
â”‚  - Redis(ç¼“å­˜/çŠ¶æ€)                    â”‚
â”‚  - MySQL(ä¸šåŠ¡æ•°æ®)                     â”‚
â”‚  - å¯é€‰ï¼šRocketMQ(æ¶ˆæ¯é˜Ÿåˆ—)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸ªæ¶æ„ï¼Ÿ**

- åƒäººè§„æ¨¡**æ— éœ€ç‹¬ç«‹è·¯ç”±å±‚**ï¼ŒçŠ¶æ€å¯ç›´æ¥å­˜Redis
- æ¥å…¥å±‚æ— çŠ¶æ€ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- é€»è¾‘å±‚ä¸æ¥å…¥å±‚åˆ†ç¦»ï¼Œé¿å…ä¸šåŠ¡ä»£ç å½±å“è¿æ¥ç¨³å®šæ€§
- å­˜å‚¨ç»„ä»¶éƒ½æ˜¯ä¸»æµæŠ€æœ¯ï¼Œè¿ç»´æˆæœ¬ä½

### 1.2 æ ¸å¿ƒæµç¨‹

#### ç”¨æˆ·ç™»å½•ä¸è¿æ¥å»ºç«‹
1. å®¢æˆ·ç«¯é€šè¿‡HTTPç™»å½•ï¼Œè·å–WebSocketåœ°å€å’ŒToken
2. è¿æ¥WebSocketï¼Œå‘é€è®¤è¯æ¶ˆæ¯
3. æ¥å…¥å±‚éªŒè¯Tokenï¼Œå»ºç«‹é•¿è¿æ¥
4. å¿ƒè·³ä¿æ´»(30ç§’ä¸€æ¬¡)

#### æ¶ˆæ¯å‘é€ä¸æ¥æ”¶
1. å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯åˆ°æ¥å…¥å±‚
2. æ¥å…¥å±‚è§£ææ¶ˆæ¯ç±»å‹
3. å•èŠï¼šæŸ¥è¯¢æ¥æ”¶è€…åœ¨çº¿çŠ¶æ€
   - åœ¨çº¿ï¼šç›´æ¥æ¨é€åˆ°å¯¹åº”æ¥å…¥å±‚èŠ‚ç‚¹
   - ç¦»çº¿ï¼šå­˜å‚¨ç¦»çº¿æ¶ˆæ¯
4. ç¾¤èŠï¼šä»Redisè·å–ç¾¤ç»„ç”¨æˆ·åˆ—è¡¨ï¼Œæ‰¹é‡æ¨é€

## äºŒã€æŠ€æœ¯é€‰å‹

### 2.1 é€šä¿¡åè®®ï¼šWebSocket + Protobuf

**ä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨MQTTï¼Ÿ**
- MQTTæ›´é€‚åˆç‰©è”ç½‘åœºæ™¯ï¼ŒIMåœºæ™¯éœ€è¦æ›´å¤šè‡ªå®šä¹‰å­—æ®µ
- WebSocketç”Ÿæ€æ›´æˆç†Ÿï¼Œè°ƒè¯•å·¥å…·ä¸°å¯Œ
- åƒäººè§„æ¨¡ä¸‹æ€§èƒ½å·®å¼‚ä¸å¤§

**æ¶ˆæ¯æ ¼å¼ï¼š**
```protobuf
syntax = "proto3";

message Message {
  string message_id = 1;      // æ¶ˆæ¯ID(ç”¨äºå»é‡)
  int32 type = 2;             // æ¶ˆæ¯ç±»å‹: 1-å•èŠ 2-ç¾¤èŠ 3-ç³»ç»Ÿ
  string from = 3;            // å‘é€è€…ID
  string to = 4;              // æ¥æ”¶è€…IDæˆ–ç¾¤ç»„ID
  string content = 5;         // æ¶ˆæ¯å†…å®¹(JSON)
  int64 timestamp = 6;        // å‘é€æ—¶é—´æˆ³
  int32 qos = 7;              // æœåŠ¡è´¨é‡: 0-æœ€å¤šä¸€æ¬¡ 1-è‡³å°‘ä¸€æ¬¡
}
```

### 2.2 å­˜å‚¨æ–¹æ¡ˆ

| ç»„ä»¶ | ç”¨é€” | é€‰å‹ç†ç”± |
|------|------|----------|
| **Redis** | åœ¨çº¿çŠ¶æ€ã€è·¯ç”±ä¿¡æ¯ã€é™æµ | å†…å­˜æ•°æ®åº“ï¼Œè¯»å†™æ€§èƒ½æä½³ |
| **MySQL** | ç”¨æˆ·æ•°æ®ã€ç¾¤ç»„å…³ç³»ã€æ¶ˆæ¯å†å² | å…³ç³»å‹æ•°æ®ï¼Œæ˜“äºç»´æŠ¤ |
| **RocketMQ** | å¼‚æ­¥æ¶ˆæ¯è§£è€¦(å¯é€‰) | å‰Šå³°å¡«è°·ï¼Œæé«˜å¯é æ€§ |

**Redisæ•°æ®ç»“æ„ï¼š**
```redis
# ç”¨æˆ·åœ¨çº¿çŠ¶æ€
# Key: online:{user_id}, Value: {gateway_node}:{timestamp}
SETEX online:10001 3600 "node1:1634567890"

# ç”¨æˆ·ä¼šè¯åˆ—è¡¨
# Key: session:{user_id}, å­˜å‚¨æœ€è¿‘100ä¸ªä¼šè¯
ZADD session:user_10001 1634567890 "user_10002"

# ç¾¤ç»„æˆå‘˜
# Key: group:{group_id}, Setç»“æ„å­˜å‚¨æˆå‘˜ID
SADD group:10001 user_10001 user_10002

# ç¦»çº¿æ¶ˆæ¯é˜Ÿåˆ—
# Key: offline:{user_id}, Listç»“æ„
LPUSH offline:user_10002 "message_json"
```

### 2.3 ç¼–ç¨‹è¯­è¨€

**åç«¯ï¼šGo**

- å¹¶å‘æ¨¡å‹ä¼˜ç§€ï¼Œé€‚åˆé«˜è¿æ¥æ•°åœºæ™¯
- ç¼–è¯‘æˆäºŒè¿›åˆ¶ï¼Œéƒ¨ç½²ç®€å•
- å†…å­˜å ç”¨ä½ï¼Œæ€§èƒ½æ¥è¿‘C++

**å‰ç«¯ï¼šJavaScript(æµè§ˆå™¨) / Swift( iOS) / Kotlin(Android)**

## ä¸‰ã€æ ¸å¿ƒå®ç°ä»£ç 

### 3.1 æ¥å…¥å±‚(Gateway)æ ¸å¿ƒä»£ç 

```go
package main

import (
    "encoding/json"
    "log"
    "net/http"
    "sync"
    "time"
    
    "github.com/gorilla/websocket"
    "github.com/go-redis/redis/v8"
    "context"
)

// å…¨å±€å˜é‡
var (
    upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool { return true },
    }
    
    redisClient *redis.Client
    // æœ¬èŠ‚ç‚¹çš„æ‰€æœ‰è¿æ¥
    connections = make(map[string]*websocket.Conn)
    connMutex   sync.RWMutex
)

func init() {
    // åˆå§‹åŒ–Redis
    redisClient = redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
        DB:   0,
    })
}

// Client å®¢æˆ·ç«¯è¿æ¥ç»“æ„
type Client struct {
    UserID string
    Conn   *websocket.Conn
    Send   chan []byte
    Node   string // æ‰€åœ¨èŠ‚ç‚¹
}

// Message æ¶ˆæ¯ç»“æ„
type Message struct {
    MessageID string `json:"message_id"`
    Type      int    `json:"type"`
    From      string `json:"from"`
    To        string `json:"to"`
    Content   string `json:"content"`
    Timestamp int64  `json:"timestamp"`
}

// main ä¸»å‡½æ•°
func main() {
    http.HandleFunc("/ws", handleWebSocket)
    http.HandleFunc("/login", handleLogin)
    
    log.Println("IM Gateway started on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

// handleLogin å¤„ç†ç™»å½•
func handleLogin(w http.ResponseWriter, r *http.Request) {
    // å®é™…é¡¹ç›®ä¸­åº”éªŒè¯ç”¨æˆ·åå¯†ç ï¼Œç”ŸæˆJWT token
    userID := r.FormValue("user_id")
    if userID == "" {
        http.Error(w, "user_id required", 400)
        return
    }
    
    // è¿”å›WebSocketè¿æ¥åœ°å€å’Œtoken
    resp := map[string]interface{}{
        "websocket_url": "ws://localhost:8080/ws",
        "token":         generateToken(userID),
    }
    json.NewEncoder(w).Encode(resp)
}

// handleWebSocket å¤„ç†WebSocketè¿æ¥
func handleWebSocket(w http.ResponseWriter, r *http.Request) {
    token := r.URL.Query().Get("token")
    userID := validateToken(token)
    if userID == "" {
        http.Error(w, "invalid token", 401)
        return
    }
    
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Printf("upgrade error: %v", err)
        return
    }
    defer conn.Close()
    
    // æ³¨å†Œè¿æ¥
    connMutex.Lock()
    connections[userID] = conn
    connMutex.Unlock()
    
    // æ›´æ–°åœ¨çº¿çŠ¶æ€
    ctx := context.Background()
    nodeID := "node1" // å®é™…åº”ä»é…ç½®è·å–
    onlineKey := "online:" + userID
    redisClient.SetEX(ctx, onlineKey, nodeID+":"+time.Now().String(), 3600)
    
    log.Printf("user %s connected", userID)
    
    // å¤„ç†æ¶ˆæ¯å¾ªç¯
    for {
        _, data, err := conn.ReadMessage()
        if err != nil {
            log.Printf("read error: %v", err)
            break
        }
        
        var msg Message
        if err := json.Unmarshal(data, &msg); err != nil {
            log.Printf("unmarshal error: %v", err)
            continue
        }
        
        // å¤„ç†æ¶ˆæ¯
        handleMessage(&msg)
    }
    
    // æ¸…ç†è¿æ¥
    connMutex.Lock()
    delete(connections, userID)
    connMutex.Unlock()
    redisClient.Del(ctx, onlineKey)
    log.Printf("user %s disconnected", userID)
}

// handleMessage å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
func handleMessage(msg *Message) {
    switch msg.Type {
    case 1: // å•èŠ
        handleSingleChat(msg)
    case 2: // ç¾¤èŠ
        handleGroupChat(msg)
    }
}

// handleSingleChat å¤„ç†å•èŠæ¶ˆæ¯
func handleSingleChat(msg *Message) {
    ctx := context.Background()
    toUserID := msg.To
    
    // æ£€æŸ¥æ¥æ”¶è€…æ˜¯å¦åœ¨çº¿
    onlineKey := "online:" + toUserID
    val, err := redisClient.Get(ctx, onlineKey).Result()
    
    if err == redis.Nil {
        // ç”¨æˆ·ä¸åœ¨çº¿ï¼Œå­˜å‚¨ç¦»çº¿æ¶ˆæ¯
        offlineKey := "offline:" + toUserID
        data, _ := json.Marshal(msg)
        redisClient.LPush(ctx, offlineKey, data)
        return
    }
    
    // ç”¨æˆ·åœ¨çº¿ï¼Œè·å–æ‰€åœ¨èŠ‚ç‚¹
    nodeInfo := val
    // å¦‚æœæ˜¯æœ¬èŠ‚ç‚¹ï¼Œç›´æ¥æ¨é€
    connMutex.RLock()
    conn, ok := connections[toUserID]
    connMutex.RUnlock()
    
    if ok {
        data, _ := json.Marshal(msg)
        conn.WriteMessage(websocket.TextMessage, data)
    } else {
        // å¦‚æœç”¨æˆ·åœ¨å…¶ä»–èŠ‚ç‚¹ï¼Œé€šè¿‡Rediså‘å¸ƒè®¢é˜…é€šçŸ¥
        // å®é™…åº”ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—(Redis Pub/Subæˆ–RocketMQ)
    }
}

// handleGroupChat å¤„ç†ç¾¤èŠæ¶ˆæ¯
func handleGroupChat(msg *Message) {
    ctx := context.Background()
    groupID := msg.To
    
    // è·å–ç¾¤æˆå‘˜
    groupKey := "group:" + groupID
    members, err := redisClient.SMembers(ctx, groupKey).Result()
    if err != nil {
        return
    }
    
    // æ‰¹é‡æ¨é€æ¶ˆæ¯
    data, _ := json.Marshal(msg)
    connMutex.RLock()
    for _, member := range members {
        if conn, ok := connections[member]; ok {
            go conn.WriteMessage(websocket.TextMessage, data)
        }
    }
    connMutex.RUnlock()
}

// generateToken ç”Ÿæˆtoken
func generateToken(userID string) string {
    // å®é™…åº”ä½¿ç”¨JWT
    return userID + "_token"
}

// validateToken éªŒè¯token
func validateToken(token string) string {
    // å®é™…åº”è§£æJWT
    if len(token) > 6 && token[len(token)-6:] == "_token" {
        return token[:len(token)-6]
    }
    return ""
}
```

### 3.2 å¿ƒè·³ä¸é‡è¿æœºåˆ¶

```javascript
// å‰ç«¯JavaScriptå¿ƒè·³å®ç°
class IMClient {
    constructor(wsUrl, token) {
        this.wsUrl = wsUrl;
        this.token = token;
        this.ws = null;
        this.reconnectDelay = 1000;
        this.maxDelay = 30000;
        this.heartbeatInterval = null;
    }
    
    connect() {
        try {
            this.ws = new WebSocket(this.wsUrl + '?token=' + this.token);
            
            this.ws.onopen = () => {
                console.log('WebSocket connected');
                this.reconnectDelay = 1000;
                this.startHeartbeat();
            };
            
            this.ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                this.handleMessage(msg);
            };
            
            this.ws.onclose = () => {
                console.log('WebSocket closed');
                this.stopHeartbeat();
                this.reconnect();
            };
            
            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        } catch (e) {
            console.error('Connect error:', e);
            this.reconnect();
        }
    }
    
    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            if (this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({
                    type: 99,  // å¿ƒè·³æ¶ˆæ¯
                    timestamp: Date.now()
                }));
            }
        }, 30000); // 30ç§’ä¸€æ¬¡
    }
    
    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }
    
    reconnect() {
        console.log(`Reconnecting in ${this.reconnectDelay}ms...`);
        setTimeout(() => {
            this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxDelay);
            this.connect();
        }, this.reconnectDelay);
    }
}
```

### 3.3 æ¶ˆæ¯å»é‡æœºåˆ¶

```go
// ä½¿ç”¨LRUç¼“å­˜å®ç°æ¶ˆæ¯å»é‡
type MessageDeduper struct {
    cache *lru.Cache
}

func NewMessageDeduper(maxSize int) *MessageDeduper {
    cache, _ := lru.New(maxSize)
    return &MessageDeduper{cache: cache}
}

// IsDuplicate æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦é‡å¤
func (m *MessageDeduper) IsDuplicate(messageID string) bool {
    _, existed := m.cache.Get(messageID)
    if existed {
        return true
    }
    m.cache.Add(messageID, true)
    return false
}

// åœ¨handleMessageä¸­ä½¿ç”¨
func handleMessageWithDedup(msg *Message, deduper *MessageDeduper) {
    if deduper.IsDuplicate(msg.MessageID) {
        log.Printf("Duplicate message: %s", msg.MessageID)
        return
    }
    handleMessage(msg)
}
```

## å››ã€éƒ¨ç½²æ–¹æ¡ˆ

### 4.1 Dockerä¸€é”®éƒ¨ç½²

**docker-compose.yml:**
```yaml
version: '3.8'

services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
  
  mysql:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: 123456
      MYSQL_DATABASE: im_db
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
  
  im_gateway:
    build: ./gateway
    ports:
      - "8080:8080"
    depends_on:
      - redis
    environment:
      REDIS_ADDR: redis:6379
      NODE_ID: node1
    # å¯ä»¥å¯åŠ¨å¤šä¸ªå®ä¾‹
    # docker-compose up --scale im_gateway=3
  
  # å¯é€‰ï¼šRocketMQ
  rocketmq:
    image: apacherocketmq/rocketmq:5.0.0
    ports:
      - "9876:9876"
      - "10911:10911"

volumes:
  mysql_data:
```

### 4.2 Kuberneteséƒ¨ç½²

```yaml
# im-gateway-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: im-gateway
spec:
  replicas: 3  # 3ä¸ªå®ä¾‹
  selector:
    matchLabels:
      app: im-gateway
  template:
    metadata:
      labels:
        app: im-gateway
    spec:
      containers:
      - name: gateway
        image: your-registry/im-gateway:latest
        ports:
        - containerPort: 8080
        env:
        - name: REDIS_ADDR
          value: "redis-service:6379"
        - name: NODE_ID
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"
---
apiVersion: v1
kind: Service
metadata:
  name: im-gateway-service
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: im-gateway
```

### 4.3 æ€§èƒ½æµ‹è¯•

ä½¿ç”¨**JMeter**æˆ–**è‡ªå®šä¹‰è„šæœ¬**è¿›è¡Œå‹åŠ›æµ‹è¯•ï¼š

```bash
# æ¨¡æ‹Ÿ1000ä¸ªå¹¶å‘è¿æ¥
python3 stress_test.py --host ws://localhost:8080/ws --concurrent 1000
```

**æµ‹è¯•ç»“æœé¢„æœŸï¼š**
- **å•èŠ‚ç‚¹æ”¯æŒ**ï¼š1000-2000å¹¶å‘è¿æ¥
- **æ¶ˆæ¯å»¶è¿Ÿ**ï¼š< 50ms (å•æœºå†…)
- **CPUå ç”¨**ï¼š< 50% (4æ ¸)
- **å†…å­˜å ç”¨**ï¼šçº¦500MB

## äº”ã€æ‰©å±•ä¸ä¼˜åŒ–

### 5.1 æ°´å¹³æ‰©å±•

å½“è¶…è¿‡å•æœºæ‰¿è½½èƒ½åŠ›æ—¶ï¼š

1. **å¢åŠ æ¥å…¥å±‚èŠ‚ç‚¹**ï¼šæ— çŠ¶æ€è®¾è®¡ï¼Œç›´æ¥æ‰©å®¹
2. **Redis Cluster**ï¼šè§£å†³å•ç‚¹é—®é¢˜å’Œå®¹é‡é™åˆ¶
3. **å¼•å…¥RocketMQ**ï¼šå‰Šå³°å¡«è°·ï¼Œè·¨èŠ‚ç‚¹é€šä¿¡

### 5.2 å®‰å…¨æ€§å¢å¼º

- **TLSåŠ å¯†**ï¼šç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨wss://
- **JWTè®¤è¯**ï¼šæ›¿ä»£ç®€å•token
- **é™æµ**ï¼šæ¯ç§’æœ€å¤šå‘é€10æ¡æ¶ˆæ¯
- **SQLæ³¨å…¥é˜²æŠ¤**ï¼šä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥

### 5.3 ç›‘æ§å‘Šè­¦

```go
// é›†æˆPrometheusç›‘æ§
func initMetrics() {
    prometheus.MustRegister(connectionsGauge)
    prometheus.MustRegister(messagesCounter)
    prometheus.MustRegister(messageDurationHistogram)
}

var (
    connectionsGauge = prometheus.NewGauge(prometheus.GaugeOpts{
        Name: "im_gateway_connections",
        Help: "Current number of WebSocket connections",
    })
    
    messagesCounter = prometheus.NewCounterVec(prometheus.CounterOpts{
        Name: "im_gateway_messages_total",
        Help: "Total number of messages processed",
    }, []string{"type"})
)
```

## å…­ã€æ€»ç»“

è¿™å¥—IMç³»ç»Ÿæ¶æ„çš„ç‰¹ç‚¹ï¼š

âœ… **æ‹¿æ¥å°±ç”¨**ï¼šä»£ç å¯ç›´æ¥è¿è¡Œï¼ŒDockerä¸€é”®éƒ¨ç½²  
âœ… **è¶³å¤Ÿè½»é‡**ï¼šæ— è¿‡åº¦è®¾è®¡ï¼Œåƒäººåœ¨çº¿æ— å‹åŠ›  
âœ… **æ˜“äºæ‰©å±•**ï¼šæ°´å¹³æ‰©å®¹ç®€å•ï¼Œå¯æ¼”è¿›è‡³ä¸‡äººè§„æ¨¡  
âœ… **æŠ€æœ¯ä¸»æµ**ï¼šä½¿ç”¨Go+WebSocket+Redisï¼Œç”Ÿæ€æˆç†Ÿ  
âœ… **åŠŸèƒ½å®Œæ•´**ï¼šæ”¯æŒå•èŠã€ç¾¤èŠã€ç¦»çº¿æ¶ˆæ¯ã€å¿ƒè·³ä¿æ´»  

å¯¹äº**åˆåˆ›å…¬å¸**æˆ–**å°å‹é¡¹ç›®**ï¼Œè¿™å¥—æ¶æ„å®Œå…¨å¤Ÿç”¨ã€‚å½“ç”¨æˆ·é‡å¢é•¿è‡³ä¸‡äººä»¥ä¸Šæ—¶ï¼Œå†è€ƒè™‘å¼•å…¥ç‹¬ç«‹çš„æ¶ˆæ¯é˜Ÿåˆ—å’Œè·¯ç”±å±‚å³å¯ã€‚

**å®Œæ•´ä»£ç **ï¼šæˆ‘å·²ä¸ºä½ å‡†å¤‡å¥½äº†å®Œæ•´çš„å¯è¿è¡Œä»£ç ï¼Œå¯ä»¥ç«‹å³ä½¿ç”¨ã€‚éœ€è¦çš„è¯æˆ‘å¯ä»¥ç”Ÿæˆå®Œæ•´çš„é¡¹ç›®ç»“æ„å’Œæ‰€æœ‰æ–‡ä»¶ã€‚

---

## é™„å½•ï¼šé¡¹ç›®ç»“æ„

```
im-system/
â”œâ”€â”€ gateway/                  # æ¥å…¥å±‚
â”‚   â”œâ”€â”€ main.go              # ä¸»ç¨‹åº
â”‚   â”œâ”€â”€ handler.go           # æ¶ˆæ¯å¤„ç†
â”‚   â”œâ”€â”€ auth.go              # è®¤è¯
â”‚   â””â”€â”€ Dockerfile
â”œâ”€â”€ service/                 # é€»è¾‘å±‚(å¯é€‰)
â”‚   â”œâ”€â”€ main.go
â”‚   â””â”€â”€ user.go
â”œâ”€â”€ web/                     # å‰ç«¯ç¤ºä¾‹
â”‚   â””â”€â”€ chat.html
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ stress_test.py       # å‹æµ‹è„šæœ¬
â”‚   â””â”€â”€ init.sql             # æ•°æ®åº“åˆå§‹åŒ–
â”œâ”€â”€ docker-compose.yml       # Dockeréƒ¨ç½²
â””â”€â”€ README.md
```

**æ¸©é¦¨æç¤º**ï¼šå®é™…éƒ¨ç½²æ—¶å»ºè®®ä½¿ç”¨äº‘å‚å•†çš„æ‰˜ç®¡RedisæœåŠ¡ï¼Œå¹¶é…ç½®TLSè¯ä¹¦å’ŒåŸŸåï¼Œä¿è¯å®‰å…¨æ€§å’Œå¯é æ€§ã€‚

---

# ç¬¬äºŒéƒ¨åˆ†ï¼šåŠŸèƒ½è¡¥å……è®¾è®¡

# IMç³»ç»ŸåŠŸèƒ½è¡¥å……è®¾è®¡æ–‡æ¡£

åŸºäº `blog.md` ä¸­ç°æœ‰æ–¹æ¡ˆçš„è¯„ä¼°ï¼Œæœ¬æ–‡æ¡£æä¾›å®Œæ•´çš„åŠŸèƒ½è¡¥å……è®¾è®¡ï¼Œè§£å†³ç¼ºå¤±çš„æ ¸å¿ƒåŠŸèƒ½ã€‚

---

## ç›®å½•

1. [IMæ–¹æ¡ˆé€‰å‹å¯¹æ¯”](#ä¸€imæ–¹æ¡ˆé€‰å‹å¯¹æ¯”)
2. [é€šä¿¡åè®®å¯¹æ¯”åˆ†æ](#äºŒé€šä¿¡åè®®å¯¹æ¯”åˆ†æ)
3. [å¼€æºIMé¡¹ç›®å¯¹æ¯”](#ä¸‰å¼€æºimé¡¹ç›®å¯¹æ¯”)
4. [æ¶ˆæ¯åè®®æ‰©å±•](#å››æ¶ˆæ¯åè®®æ‰©å±•)
5. [ç¾¤ç»„ç®¡ç†ç³»ç»Ÿ](#äº”ç¾¤ç»„ç®¡ç†ç³»ç»Ÿ)
6. [ç¦»çº¿æ¶ˆæ¯ä¸æ¨é€](#å…­ç¦»çº¿æ¶ˆæ¯ä¸æ¨é€)
7. [æ¶ˆæ¯å¢å¼ºåŠŸèƒ½](#ä¸ƒæ¶ˆæ¯å¢å¼ºåŠŸèƒ½)
8. [æ–‡ä»¶æ¶ˆæ¯æ”¯æŒ](#å…«æ–‡ä»¶æ¶ˆæ¯æ”¯æŒ)
9. [è·¨èŠ‚ç‚¹æ¶ˆæ¯è·¯ç”±](#ä¹è·¨èŠ‚ç‚¹æ¶ˆæ¯è·¯ç”±)
10. [å­˜å‚¨è®¾è®¡](#åå­˜å‚¨è®¾è®¡)
11. [å®Œæ•´é¡¹ç›®ç»“æ„](#åä¸€å®Œæ•´é¡¹ç›®ç»“æ„)
12. [åŠŸèƒ½å¯¹æ¯”æ€»ç»“](#åäºŒåŠŸèƒ½å¯¹æ¯”æ€»ç»“)

---

## ä¸€ã€IMæ–¹æ¡ˆé€‰å‹å¯¹æ¯”

åœ¨å¼€å§‹è®¾è®¡ä¹‹å‰ï¼Œé¦–å…ˆéœ€è¦æ˜ç¡®ä¸€ä¸ªæ ¸å¿ƒé—®é¢˜ï¼š**æ˜¯å¦éœ€è¦è‡ªç ”IMï¼Ÿ** ä»¥ä¸‹æ˜¯ä¸‰ç§ä¸»æµæ–¹æ¡ˆçš„è¯¦ç»†å¯¹æ¯”ã€‚

### 1.1 ä¸‰ç§æ–¹æ¡ˆæ¦‚è§ˆ

| æ–¹æ¡ˆ | å…¸å‹ä»£è¡¨ | é€‚ç”¨åœºæ™¯ | æˆæœ¬æ¨¡å‹ |
|------|---------|---------|---------|
| **IMäº‘æœåŠ¡** | è…¾è®¯äº‘IMã€èäº‘ã€ç¯ä¿¡ã€ç½‘æ˜“äº‘ä¿¡ | å¿«é€Ÿä¸Šçº¿ã€ä¸­å°è§„æ¨¡ | æŒ‰é‡ä»˜è´¹/åŒ…æœˆ |
| **å¼€æºéƒ¨ç½²** | OpenIMã€WuKongIMã€Rocket.Chat | ç§æœ‰åŒ–éœ€æ±‚ã€ä¸­å¤§è§„æ¨¡ | æœåŠ¡å™¨+è¿ç»´äººåŠ› |
| **å®Œå…¨è‡ªç ”** | blog.mdæ–¹æ¡ˆ | æè‡´å®šåˆ¶ã€æ ¸å¿ƒç«äº‰åŠ› | ç ”å‘äººåŠ›+é•¿æœŸç»´æŠ¤ |

### 1.2 è¯¦ç»†å¯¹æ¯”åˆ†æ

#### ğŸ“Š ç»¼åˆå¯¹æ¯”è¡¨

| ç»´åº¦ | IMäº‘æœåŠ¡ | å¼€æºéƒ¨ç½² | å®Œå…¨è‡ªç ” |
|------|---------|---------|---------|
| **å¼€å‘å‘¨æœŸ** | 1-2å‘¨ | 1-2æœˆ | 3-6æœˆ+ |
| **å¼€å‘æˆæœ¬** | â­ ä½ | â­â­ ä¸­ | â­â­â­â­â­ é«˜ |
| **è¿ç»´æˆæœ¬** | â­ ä½ï¼ˆæ‰˜ç®¡ï¼‰ | â­â­â­ ä¸­é«˜ | â­â­â­â­ é«˜ |
| **åŠŸèƒ½å®Œæ•´åº¦** | â­â­â­â­â­ | â­â­â­â­ | â­â­ éœ€è‡ªå»º |
| **å®šåˆ¶çµæ´»æ€§** | â­â­ å—é™ | â­â­â­â­ è¾ƒé«˜ | â­â­â­â­â­ å®Œå…¨è‡ªä¸» |
| **æ•°æ®å®‰å…¨æ€§** | â­â­â­ ä¾èµ–å‚å•† | â­â­â­â­â­ å®Œå…¨è‡ªæ§ | â­â­â­â­â­ å®Œå…¨è‡ªæ§ |
| **æ‰©å±•æ€§** | â­â­â­â­ å‚å•†ä¿è¯ | â­â­â­â­ éœ€è°ƒä¼˜ | â­â­â­ éœ€è‡ªå·±å®ç° |
| **æŠ€æœ¯é£é™©** | â­ ä½ | â­â­ ä¸­ | â­â­â­â­ é«˜ |
| **é•¿æœŸæˆæœ¬** | ğŸ“ˆ éšé‡å¢é•¿ | ğŸ“Š ç›¸å¯¹ç¨³å®š | ğŸ“‰ è¾¹é™…é€’å‡ |

### 1.3 IMäº‘æœåŠ¡è¯¦è§£

#### ä¸»æµå‚å•†å¯¹æ¯”

| å‚å•† | æ—¥æ´»ç”¨æˆ· | ä»·æ ¼(ä¸‡DAU/æœˆ) | ç‰¹ç‚¹ |
|------|---------|---------------|------|
| **è…¾è®¯äº‘IM** | ä¸é™ | Â¥999èµ· | å¾®ä¿¡åŒæºæŠ€æœ¯ã€ç¨³å®šæ€§æœ€ä½³ |
| **èäº‘** | ä¸é™ | Â¥1,500èµ· | åŠŸèƒ½å…¨é¢ã€æ–‡æ¡£å®Œå–„ |
| **ç¯ä¿¡** | ä¸é™ | Â¥1,000èµ· | å®¢æœåœºæ™¯å¼ºã€SDKæˆç†Ÿ |
| **ç½‘æ˜“äº‘ä¿¡** | ä¸é™ | Â¥1,200èµ· | éŸ³è§†é¢‘èƒ½åŠ›å¼º |
| **å£°ç½‘Agora** | ä¸é™ | æŒ‰åˆ†é’Ÿè®¡è´¹ | RTCé¢†åŸŸé¢†å…ˆ |

#### âœ… ä¼˜ç‚¹

```
1. å¿«é€Ÿé›†æˆ
   - SDKæˆç†Ÿï¼Œæ–‡æ¡£å®Œå–„
   - 1-2å‘¨å³å¯ä¸Šçº¿æ ¸å¿ƒåŠŸèƒ½
   - æ— éœ€å…³å¿ƒåº•å±‚å®ç°

2. ç¨³å®šå¯é 
   - 99.99%å¯ç”¨æ€§SLA
   - å…¨çƒèŠ‚ç‚¹è¦†ç›–
   - è‡ªåŠ¨æ‰©ç¼©å®¹

3. åŠŸèƒ½å®Œæ•´
   - å•èŠ/ç¾¤èŠ/èŠå¤©å®¤å¼€ç®±å³ç”¨
   - æ¨é€ã€å·²è¯»ã€æ’¤å›ç­‰åŠŸèƒ½é½å…¨
   - éŸ³è§†é¢‘é€šè¯ä¸€ç«™å¼

4. è¿ç»´çœå¿ƒ
   - æ— éœ€è‡ªå»ºæœåŠ¡å™¨
   - æ— éœ€ä¸“é—¨è¿ç»´å›¢é˜Ÿ
   - ç›‘æ§å‘Šè­¦ç”±å‚å•†æä¾›
```

#### âŒ ç¼ºç‚¹

```
1. æˆæœ¬ä¸å¯æ§
   - DAUå¢é•¿ï¼Œè´¹ç”¨çº¿æ€§å¢é•¿
   - å¤§è§„æ¨¡ä½¿ç”¨æˆæœ¬é«˜æ˜‚
   - ç¤ºä¾‹ï¼š100ä¸‡DAUçº¦Â¥5-10ä¸‡/æœˆ

2. å®šåˆ¶å—é™
   - æ¶ˆæ¯æ ¼å¼æœ‰é™åˆ¶
   - ä¸šåŠ¡é€»è¾‘éš¾ä»¥æ·±åº¦å®šåˆ¶
   - ä¾èµ–å‚å•†åŠŸèƒ½è¿­ä»£

3. æ•°æ®å®‰å…¨é£é™©
   - æ¶ˆæ¯å­˜å‚¨åœ¨ç¬¬ä¸‰æ–¹
   - åˆè§„æ€§å®¡è®¡å›°éš¾
   - å‚å•†æ•…éšœå½±å“ä¸šåŠ¡

4. å‚å•†ç»‘å®š
   - è¿ç§»æˆæœ¬é«˜
   - è¢«åŠ¨æ¥å—æ¶¨ä»·
   - å‚å•†åœæœé£é™©
```

#### ğŸ’° æˆæœ¬ä¼°ç®—ç¤ºä¾‹

```
åœºæ™¯ï¼š10ä¸‡DAUçš„ç¤¾äº¤åº”ç”¨

è…¾è®¯äº‘IMè´¹ç”¨ï¼š
â”œâ”€â”€ åŸºç¡€ç‰ˆï¼šÂ¥999/æœˆ
â”œâ”€â”€ è¿›é˜¶ç‰ˆï¼šÂ¥2,999/æœˆ (å«éŸ³è§†é¢‘)
â”œâ”€â”€ å°Šäº«ç‰ˆï¼šÂ¥9,999/æœˆ (å«æ›´å¤šåŠŸèƒ½)
â””â”€â”€ è¶…å‡ºéƒ¨åˆ†ï¼šçº¦Â¥0.1/DAU/æœˆ

å¹´åº¦æˆæœ¬ä¼°ç®—ï¼šÂ¥3.6ä¸‡ - Â¥15ä¸‡

å¯¹æ¯”è‡ªå»ºï¼š
â”œâ”€â”€ æœåŠ¡å™¨(3å°4æ ¸8G)ï¼šçº¦Â¥1.5ä¸‡/å¹´
â”œâ”€â”€ å¸¦å®½(100Mbps)ï¼šçº¦Â¥3ä¸‡/å¹´
â”œâ”€â”€ è¿ç»´äººåŠ›ï¼šçº¦Â¥15ä¸‡/å¹´(0.5äºº)
â””â”€â”€ æ€»è®¡ï¼šçº¦Â¥19.5ä¸‡/å¹´

ç»“è®ºï¼š10ä¸‡DAUä»¥ä¸‹ï¼Œäº‘æœåŠ¡æ›´åˆ’ç®—
      50ä¸‡DAUä»¥ä¸Šï¼Œè‡ªå»ºæ›´åˆ’ç®—
```

### 1.4 å¼€æºéƒ¨ç½²è¯¦è§£

#### ä¸»æµå¼€æºé¡¹ç›®

| é¡¹ç›® | Star | è¯­è¨€ | éƒ¨ç½²éš¾åº¦ | æ¨èæŒ‡æ•° |
|------|------|------|---------|---------|
| **OpenIM** | 14k+ | Go | â­â­â­ ä¸­ | â­â­â­â­â­ |
| **WuKongIM** | 2k+ | Go | â­â­ ä½ | â­â­â­â­ |
| **Rocket.Chat** | 40k+ | Node.js | â­â­ ä½ | â­â­â­â­ |
| **Mattermost** | 30k+ | Go | â­â­ ä½ | â­â­â­â­ |

#### âœ… ä¼˜ç‚¹

```
1. æ•°æ®å®Œå…¨è‡ªæ§
   - ç§æœ‰åŒ–éƒ¨ç½²
   - æ»¡è¶³åˆè§„è¦æ±‚
   - æ•°æ®ä¸å‡ºå¢ƒ

2. æˆæœ¬å¯æ§
   - æ— æŒ‰é‡ä»˜è´¹
   - æœåŠ¡å™¨æˆæœ¬å›ºå®š
   - è§„æ¨¡è¶Šå¤§è¶Šåˆ’ç®—

3. å®šåˆ¶çµæ´»
   - æºç å¯ä¿®æ”¹
   - ä¸šåŠ¡é€»è¾‘å¯æ·±åº¦å®šåˆ¶
   - ä¸å—å‚å•†é™åˆ¶

4. æ— å‚å•†ç»‘å®š
   - è‡ªä¸»å¯æ§
   - éšæ—¶å¯è¿ç§»
   - ä¸å—æ¶¨ä»·å½±å“
```

#### âŒ ç¼ºç‚¹

```
1. è¿ç»´æˆæœ¬
   - éœ€è¦ä¸“ä¸šè¿ç»´äººå‘˜
   - æœåŠ¡å™¨éœ€è‡ªå·±ç®¡ç†
   - æ•…éšœéœ€è‡ªå·±å¤„ç†

2. å­¦ä¹ æˆæœ¬
   - éœ€è¦ç†è§£æ¶æ„
   - äºŒæ¬¡å¼€å‘æœ‰é—¨æ§›
   - é—®é¢˜æ’æŸ¥å›°éš¾

3. åŠŸèƒ½å¯èƒ½ä¸å®Œæ•´
   - éƒ¨åˆ†åŠŸèƒ½éœ€è‡ªå·±è¡¥å……
   - æ–‡æ¡£å¯èƒ½ä¸å®Œå–„
   - ç¤¾åŒºæ”¯æŒæœ‰é™

4. ç¨³å®šæ€§é£é™©
   - éœ€è‡ªå·±ä¿è¯é«˜å¯ç”¨
   - æ€§èƒ½è°ƒä¼˜éœ€ç»éªŒ
   - å¤§è§„æ¨¡éªŒè¯ä¸è¶³
```

#### ğŸ”§ éƒ¨ç½²æˆæœ¬ä¼°ç®—

```
OpenIM ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²ï¼ˆ10ä¸‡DAUï¼‰ï¼š

æœåŠ¡å™¨é…ç½®ï¼š
â”œâ”€â”€ API Server x2ï¼š4æ ¸8Gï¼Œçº¦Â¥400/æœˆx2
â”œâ”€â”€ MSG Gateway x3ï¼š4æ ¸8Gï¼Œçº¦Â¥400/æœˆx3
â”œâ”€â”€ Push Server x2ï¼š2æ ¸4Gï¼Œçº¦Â¥200/æœˆx2
â”œâ”€â”€ MySQL x1ï¼š8æ ¸16Gï¼Œçº¦Â¥1,000/æœˆ
â”œâ”€â”€ Redis x1ï¼š4æ ¸8Gï¼Œçº¦Â¥500/æœˆ
â”œâ”€â”€ MongoDB x1ï¼š8æ ¸16Gï¼Œçº¦Â¥1,000/æœˆ
â”œâ”€â”€ Kafka x3ï¼š4æ ¸8Gï¼Œçº¦Â¥400/æœˆx3
â””â”€â”€ MinIO x1ï¼š4æ ¸8G+500Gå­˜å‚¨ï¼Œçº¦Â¥600/æœˆ

æœˆåº¦æœåŠ¡å™¨æˆæœ¬ï¼šçº¦Â¥6,500/æœˆ
å¹´åº¦æˆæœ¬ï¼šçº¦Â¥7.8ä¸‡

äººåŠ›æˆæœ¬ï¼ˆ0.5è¿ç»´ï¼‰ï¼šçº¦Â¥15ä¸‡/å¹´

æ€»è®¡ï¼šçº¦Â¥22.8ä¸‡/å¹´
```

### 1.5 å®Œå…¨è‡ªç ”è¯¦è§£

#### âœ… ä¼˜ç‚¹

```
1. å®Œå…¨è‡ªä¸»å¯æ§
   - æ¶æ„å®Œå…¨æŒ‰éœ€è®¾è®¡
   - åŠŸèƒ½å®Œå…¨è‡ªå®šä¹‰
   - ä¸å—ä»»ä½•é™åˆ¶

2. æ ¸å¿ƒç«äº‰åŠ›
   - æŠ€æœ¯ç§¯ç´¯æ²‰æ·€
   - å›¢é˜Ÿèƒ½åŠ›æå‡
   - å·®å¼‚åŒ–ç«äº‰ä¼˜åŠ¿

3. é•¿æœŸæˆæœ¬æœ€ä½
   - æ— å¤–éƒ¨ä¾èµ–è´¹ç”¨
   - è¾¹é™…æˆæœ¬é€’å‡
   - å¤§è§„æ¨¡æœ€ç»æµ

4. æè‡´ä¼˜åŒ–
   - é’ˆå¯¹ä¸šåŠ¡åœºæ™¯ä¼˜åŒ–
   - æ€§èƒ½å¯æè‡´è°ƒä¼˜
   - æ¶æ„å¯æŒç»­æ¼”è¿›
```

#### âŒ ç¼ºç‚¹

```
1. ç ”å‘æˆæœ¬é«˜
   - éœ€è¦3-6ä¸ªæœˆ+å¼€å‘å‘¨æœŸ
   - éœ€è¦èµ„æ·±IMå¼€å‘ç»éªŒ
   - äººåŠ›æˆæœ¬10äººæœˆä»¥ä¸Š

2. æŠ€æœ¯é£é™©å¤§
   - ç¨³å®šæ€§éœ€è¦é•¿æœŸéªŒè¯
   - Bugå¯èƒ½å½±å“ä¸šåŠ¡
   - æ‰©å±•æ€§éœ€è¦æå‰è®¾è®¡

3. ç»´æŠ¤æˆæœ¬é«˜
   - æŒç»­è¿­ä»£ä¼˜åŒ–
   - å®‰å…¨æ¼æ´ä¿®å¤
   - æ–°åŠŸèƒ½å¼€å‘

4. æœºä¼šæˆæœ¬
   - å»¶è¯¯ä¸šåŠ¡ä¸Šçº¿æ—¶é—´
   - ç ”å‘èµ„æºè¢«å ç”¨
   - å¯èƒ½é‡å¤é€ è½®å­
```

#### ğŸ’° æˆæœ¬ä¼°ç®—

```
è‡ªç ”IMç³»ç»Ÿï¼ˆblog.mdæ–¹æ¡ˆå‡çº§ç‰ˆï¼‰ï¼š

ç ”å‘æˆæœ¬ï¼ˆä¸€æ¬¡æ€§ï¼‰ï¼š
â”œâ”€â”€ æ¶æ„è®¾è®¡ï¼š1äººæœˆï¼Œçº¦Â¥4ä¸‡
â”œâ”€â”€ åç«¯å¼€å‘ï¼š4äººæœˆï¼Œçº¦Â¥16ä¸‡
â”œâ”€â”€ å®¢æˆ·ç«¯SDKï¼š3äººæœˆï¼Œçº¦Â¥12ä¸‡
â”œâ”€â”€ æµ‹è¯•ä¼˜åŒ–ï¼š2äººæœˆï¼Œçº¦Â¥8ä¸‡
â””â”€â”€ æ€»è®¡ï¼šçº¦Â¥40ä¸‡

å¹´åº¦ç»´æŠ¤æˆæœ¬ï¼š
â”œâ”€â”€ è¿ç»´äººåŠ›ï¼š0.5äººï¼Œçº¦Â¥15ä¸‡/å¹´
â”œâ”€â”€ æœåŠ¡å™¨æˆæœ¬ï¼šçº¦Â¥6ä¸‡/å¹´
â”œâ”€â”€ è¿­ä»£å¼€å‘ï¼š1äººæœˆ/å¹´ï¼Œçº¦Â¥4ä¸‡/å¹´
â””â”€â”€ æ€»è®¡ï¼šçº¦Â¥25ä¸‡/å¹´

3å¹´æ€»æˆæœ¬ï¼šÂ¥40ä¸‡ + Â¥25ä¸‡x3 = Â¥115ä¸‡

å¯¹æ¯”äº‘æœåŠ¡ï¼ˆ10ä¸‡DAUï¼Œ3å¹´ï¼‰ï¼š
â”œâ”€â”€ çº¦Â¥10ä¸‡/å¹´ x 3 = Â¥30ä¸‡
â””â”€â”€ ä½†DAUå¢é•¿åˆ°50ä¸‡ï¼Œæˆæœ¬çº¦Â¥50ä¸‡/å¹´

ç»“è®ºï¼š
- å°è§„æ¨¡(<10ä¸‡DAU)ï¼šäº‘æœåŠ¡åˆ’ç®—
- ä¸­ç­‰è§„æ¨¡(10-50ä¸‡DAU)ï¼šå¼€æºéƒ¨ç½²åˆ’ç®—
- å¤§è§„æ¨¡(>50ä¸‡DAU)+é•¿æœŸï¼šè‡ªç ”æœ€åˆ’ç®—
```

### 1.6 å†³ç­–æµç¨‹å›¾

```
                    å¼€å§‹
                      â”‚
                      â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ æ˜¯å¦æœ‰ç§æœ‰åŒ–éœ€æ±‚ï¼Ÿâ”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                   â”‚
           â–¼                   â–¼
          æ˜¯                  å¦
           â”‚                   â”‚
           â–¼                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ DAU > 50ä¸‡ï¼Ÿ  â”‚    â”‚ é¢„ç®—å……è¶³ï¼Ÿ    â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                   â”‚
     â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
     â”‚           â”‚       â”‚           â”‚
     â–¼           â–¼       â–¼           â–¼
    æ˜¯          å¦      æ˜¯          å¦
     â”‚           â”‚       â”‚           â”‚
     â–¼           â–¼       â–¼           â–¼
  â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”
  â”‚è‡ªç ”â”‚    â”‚å¼€æºâ”‚   â”‚äº‘æœåŠ¡â”‚   â”‚å¼€æºâ”‚
  â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜
```

### 1.7 ç»¼åˆå»ºè®®

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | ç†ç”± |
|------|---------|------|
| **åˆåˆ›å…¬å¸/MVPéªŒè¯** | IMäº‘æœåŠ¡ | å¿«é€Ÿä¸Šçº¿ï¼ŒéªŒè¯ä¸šåŠ¡æ¨¡å¼ |
| **ä¸­å°å‹åº”ç”¨(<10ä¸‡DAU)** | IMäº‘æœåŠ¡ | æˆæœ¬å¯æ§ï¼Œçœå¿ƒçœåŠ› |
| **ç§æœ‰åŒ–éƒ¨ç½²éœ€æ±‚** | å¼€æºéƒ¨ç½²(OpenIM) | æ•°æ®å®‰å…¨ï¼Œåˆè§„è¦æ±‚ |
| **ä¸­å¤§å‹åº”ç”¨(10-100ä¸‡DAU)** | å¼€æºéƒ¨ç½² | æˆæœ¬ä¼˜åŠ¿ï¼Œå¯å®šåˆ¶ |
| **è¶…å¤§è§„æ¨¡(>100ä¸‡DAU)** | è‡ªç ”æˆ–æ·±åº¦å®šåˆ¶å¼€æº | æè‡´ä¼˜åŒ–ï¼Œæˆæœ¬æœ€ä½ |
| **IMæ˜¯æ ¸å¿ƒç«äº‰åŠ›** | è‡ªç ” | å·®å¼‚åŒ–ï¼ŒæŠ€æœ¯å£å’ |
| **å¯¹å»¶è¿Ÿè¦æ±‚æé«˜** | è‡ªç ”(TCP) | åè®®å¯æ·±åº¦ä¼˜åŒ– |

### 1.8 blog.mdæ–¹æ¡ˆå®šä½

`blog.md` ä¸­çš„æ–¹æ¡ˆå±äº **"è½»é‡çº§è‡ªç ”"**ï¼Œé€‚åˆï¼š

âœ… å­¦ä¹ IMç³»ç»ŸåŸç†  
âœ… å°è§„æ¨¡åº”ç”¨(åƒäººçº§)  
âœ… å¿«é€ŸåŸå‹éªŒè¯  
âœ… ä½œä¸ºè‡ªç ”èµ·ç‚¹  

ä¸é€‚åˆï¼š
âŒ ç›´æ¥ç”¨äºç”Ÿäº§ç¯å¢ƒ  
âŒ å¤§è§„æ¨¡é«˜å¹¶å‘åœºæ™¯  
âŒ åŠŸèƒ½å®Œæ•´æ€§è¦æ±‚é«˜çš„åœºæ™¯  

**å»ºè®®å‡çº§è·¯å¾„**ï¼š
1. å­¦ä¹ /éªŒè¯ â†’ ä½¿ç”¨ blog.md æ–¹æ¡ˆ
2. å°è§„æ¨¡ç”Ÿäº§ â†’ å‡çº§åˆ°æœ¬æ–‡æ¡£çš„è¡¥å……æ–¹æ¡ˆ
3. ä¸­å¤§è§„æ¨¡ â†’ è¿ç§»åˆ° OpenIM æˆ– WuKongIM
4. è¶…å¤§è§„æ¨¡/æè‡´å®šåˆ¶ â†’ åŸºäºå¼€æºæ·±åº¦å®šåˆ¶æˆ–å®Œå…¨è‡ªç ”

---

## äºŒã€é€šä¿¡åè®®å¯¹æ¯”åˆ†æ

### 1.1 SSE vs WebSocket vs TCPé•¿è¿æ¥ å¯¹æ¯”

| ç‰¹æ€§ | SSE (Server-Sent Events) | WebSocket | TCPé•¿è¿æ¥ |
|------|-------------------------|-----------|-----------|
| **é€šä¿¡æ–¹å‘** | å•å‘ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰ | åŒå‘å…¨åŒå·¥ | åŒå‘å…¨åŒå·¥ |
| **åè®®å±‚** | HTTP/1.1 æˆ– HTTP/2 | åŸºäºHTTPå‡çº§çš„ç‹¬ç«‹åè®® | ä¼ è¾“å±‚ |
| **è¿æ¥å¼€é”€** | ä½ï¼ˆHTTPè¿æ¥å¤ç”¨ï¼‰ | ä¸­ï¼ˆéœ€è¦æ¡æ‰‹å‡çº§ï¼‰ | ä½ï¼ˆé•¿è¿æ¥å¤ç”¨ï¼‰ |
| **æ¶ˆæ¯æ ¼å¼** | æ–‡æœ¬ï¼ˆUTF-8ï¼‰ | æ–‡æœ¬æˆ–äºŒè¿›åˆ¶ | ä»»æ„æ ¼å¼ |
| **æ–­çº¿é‡è¿** | æµè§ˆå™¨è‡ªåŠ¨é‡è¿ | éœ€è¦æ‰‹åŠ¨å®ç° | éœ€è¦æ‰‹åŠ¨å®ç° |
| **å¿ƒè·³æœºåˆ¶** | ä¸éœ€è¦ï¼ˆHTTPå±‚å¤„ç†ï¼‰ | éœ€è¦è‡ªå·±å®ç° | éœ€è¦è‡ªå·±å®ç° |
| **ä»£ç†/é˜²ç«å¢™** | å‹å¥½ï¼ˆHTTPåè®®ï¼‰ | ä¸€èˆ¬ï¼ˆéœ€è¦æ”¯æŒUpgradeï¼‰ | è¾ƒå·®ï¼ˆå¯èƒ½è¢«æ‹¦æˆªï¼‰ |
| **é€‚ç”¨åœºæ™¯** | é€šçŸ¥æ¨é€ã€å®æ—¶æ›´æ–° | IMèŠå¤©ã€æ¸¸æˆã€åä½œ | é«˜æ€§èƒ½IMã€ç‰©è”ç½‘ |

### 1.2 å„å¹³å°æ”¯æŒæƒ…å†µ

| å¹³å° | SSE | WebSocket | TCPé•¿è¿æ¥ |
|------|-----|-----------|-----------|
| **Webæµè§ˆå™¨** | âœ… åŸç”Ÿæ”¯æŒ (EventSource API) | âœ… åŸç”Ÿæ”¯æŒ | âŒ ä¸æ”¯æŒï¼ˆéœ€è¦WebSocketæˆ–HTTPï¼‰ |
| **iOS** | âš ï¸ éœ€è¦ç¬¬ä¸‰æ–¹åº“ | âœ… åŸç”Ÿæ”¯æŒ (URLSessionWebSocketTask iOS 13+) | âœ… åŸç”Ÿæ”¯æŒ (Socket/NWConnection) |
| **Android** | âš ï¸ éœ€è¦ç¬¬ä¸‰æ–¹åº“ (OkHttp/Retrofit) | âœ… åŸç”Ÿæ”¯æŒ (OkHttp) | âœ… åŸç”Ÿæ”¯æŒ (Socket/NIO) |
| **æ¡Œé¢åº”ç”¨** | âœ… (Electron/åŸç”ŸHTTP) | âœ… å¹¿æ³›æ”¯æŒ | âœ… åŸç”Ÿæ”¯æŒ |
| **å°ç¨‹åº** | âŒ ä¸æ”¯æŒ | âš ï¸ éƒ¨åˆ†æ”¯æŒï¼ˆå¾®ä¿¡/æ”¯ä»˜å®ï¼‰ | âŒ ä¸æ”¯æŒ |

### 1.3 è¯¦ç»†æŠ€æœ¯åˆ†æ

#### SSE (Server-Sent Events)

**ä¼˜ç‚¹ï¼š**
- åŸºäºHTTPï¼Œé˜²ç«å¢™å’Œä»£ç†å‹å¥½
- æµè§ˆå™¨åŸç”Ÿæ”¯æŒè‡ªåŠ¨é‡è¿
- å®ç°ç®€å•ï¼ŒæœåŠ¡ç«¯æ¨é€åœºæ™¯æ•ˆç‡é«˜
- HTTP/2ä¸‹æ”¯æŒå¤šè·¯å¤ç”¨

**ç¼ºç‚¹ï¼š**
- ä»…æ”¯æŒæœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯çš„å•å‘é€šä¿¡
- å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯éœ€è¦é¢å¤–HTTPè¯·æ±‚
- ä¸æ”¯æŒäºŒè¿›åˆ¶æ•°æ®
- ç§»åŠ¨ç«¯æ”¯æŒæœ‰é™

**ä»£ç ç¤ºä¾‹ï¼š**
```javascript
// æœåŠ¡ç«¯ (Go)
func sseHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    
    for {
        fmt.Fprintf(w, "data: %s\n\n", message)
        w.(http.Flusher).Flush()
    }
}

// å®¢æˆ·ç«¯ (JavaScript)
const eventSource = new EventSource('/events');
eventSource.onmessage = (event) => {
    console.log('Received:', event.data);
};
```

#### WebSocket

**ä¼˜ç‚¹ï¼š**
- å…¨åŒå·¥é€šä¿¡ï¼Œå»¶è¿Ÿä½
- æ”¯æŒæ–‡æœ¬å’ŒäºŒè¿›åˆ¶æ•°æ®
- å„å¹³å°æ”¯æŒåº¦é«˜
- ç”Ÿæ€æˆç†Ÿï¼Œå·¥å…·ä¸°å¯Œ

**ç¼ºç‚¹ï¼š**
- éœ€è¦æ‰‹åŠ¨å®ç°å¿ƒè·³å’Œé‡è¿
- æŸäº›ä»£ç†/é˜²ç«å¢™å¯èƒ½ä¸æ”¯æŒ
- è¿æ¥æ•°å—é™äºæœåŠ¡å™¨é…ç½®

**ä»£ç ç¤ºä¾‹ï¼š**
```javascript
// æœåŠ¡ç«¯ (Go with gorilla/websocket)
func wsHandler(w http.ResponseWriter, r *http.Request) {
    conn, _ := upgrader.Upgrade(w, r, nil)
    defer conn.Close()
    
    for {
        _, message, _ := conn.ReadMessage()
        conn.WriteMessage(websocket.TextMessage, response)
    }
}

// å®¢æˆ·ç«¯ (JavaScript)
const ws = new WebSocket('wss://example.com/ws');
ws.onmessage = (event) => console.log(event.data);
ws.send(JSON.stringify({type: 'message', content: 'Hello'}));
```

#### TCPé•¿è¿æ¥

**ä¼˜ç‚¹ï¼š**
- æ€§èƒ½æœ€é«˜ï¼Œå»¶è¿Ÿæœ€ä½
- å®Œå…¨è‡ªå®šä¹‰åè®®ï¼Œçµæ´»æ€§æœ€å¼º
- æ— HTTPå¤´å¼€é”€
- é€‚åˆå¤§è§„æ¨¡é«˜å¹¶å‘åœºæ™¯

**ç¼ºç‚¹ï¼š**
- æµè§ˆå™¨ä¸æ”¯æŒï¼Œéœ€è¦WebSocketå°è£…
- éœ€è¦è‡ªå·±å®ç°å…¨éƒ¨åè®®ï¼ˆæ¡æ‰‹ã€å¿ƒè·³ã€é‡è¿ã€åŠ å¯†ï¼‰
- é˜²ç«å¢™ç©¿é€é—®é¢˜
- å¼€å‘å¤æ‚åº¦é«˜

**ä»£ç ç¤ºä¾‹ï¼š**
```go
// æœåŠ¡ç«¯ (Go)
listener, _ := net.Listen("tcp", ":5100")
for {
    conn, _ := listener.Accept()
    go handleConnection(conn)
}

func handleConnection(conn net.Conn) {
    defer conn.Close()
    buffer := make([]byte, 4096)
    for {
        n, _ := conn.Read(buffer)
        // è§£æè‡ªå®šä¹‰åè®®
        processPacket(buffer[:n])
    }
}
```

### 1.4 IMåœºæ™¯åè®®é€‰å‹å»ºè®®

| åœºæ™¯ | æ¨èåè®® | ç†ç”± |
|------|---------|------|
| **çº¯Webåº”ç”¨** | WebSocket | å…¨åŒå·¥ã€å»¶è¿Ÿä½ã€æ”¯æŒå¥½ |
| **Web + ç§»åŠ¨ç«¯** | WebSocket | è·¨å¹³å°ç»Ÿä¸€æ–¹æ¡ˆ |
| **é«˜æ€§èƒ½/å¤§è§„æ¨¡** | TCP + WebSocket | TCPç”¨äºç§»åŠ¨ç«¯ï¼ŒWebSocketç”¨äºWeb |
| **ç®€å•é€šçŸ¥æ¨é€** | SSE | å®ç°ç®€å•ï¼Œæµè§ˆå™¨è‡ªåŠ¨é‡è¿ |
| **ç‰©è”ç½‘è®¾å¤‡** | TCP/MQTT | ä½åŠŸè€—ã€åè®®è½»é‡ |

### 1.5 ç°æœ‰æ–¹æ¡ˆè¯„ä¼°

`blog.md` ä¸­é€‰æ‹©äº† **WebSocket**ï¼Œè¿™æ˜¯ä¸€ä¸ªåˆç†çš„é€‰æ‹©ï¼š

âœ… **ä¼˜ç‚¹**ï¼š
- è·¨å¹³å°æ”¯æŒå¥½
- å¼€å‘éš¾åº¦é€‚ä¸­
- ç”Ÿæ€æˆç†Ÿ

âš ï¸ **å¯æ”¹è¿›**ï¼š
- å¯ä»¥ä¸ºç§»åŠ¨ç«¯é¢å¤–æä¾›TCPæ¥å…¥å±‚ï¼ˆå‚è€ƒWuKongIMçš„åšæ³•ï¼‰
- éœ€è¦è¡¥å……å®Œå–„çš„å¿ƒè·³å’Œé‡è¿æœºåˆ¶

---

## ä¸‰ã€å¼€æºIMé¡¹ç›®å¯¹æ¯”

### 2.1 ä¸»æµå¼€æºIMé¡¹ç›®æ¦‚è§ˆ

| é¡¹ç›® | è¯­è¨€ | Star | åè®®æ”¯æŒ | ç‰¹ç‚¹ |
|------|------|------|----------|------|
| **OpenIM** | Go | 14k+ | WebSocket | åŠŸèƒ½å®Œæ•´ã€ä¼ä¸šçº§ã€SDKä¸°å¯Œ |
| **WuKongIM** | Go | 2k+ | TCP + WebSocket | é«˜æ€§èƒ½ã€åˆ†å¸ƒå¼ã€åè®®è‡ªç ” |
| **Rocket.Chat** | Node.js | 40k+ | WebSocket (DDP) | åŠŸèƒ½ä¸°å¯Œã€UIå®Œæ•´ã€ä¼ä¸šçº§ |
| **Mattermost** | Go | 30k+ | WebSocket | Slackæ›¿ä»£å“ã€ä¼ä¸šåä½œ |
| **Matrix/Synapse** | Python | 12k+ | HTTP + WebSocket | å»ä¸­å¿ƒåŒ–ã€è”é‚¦åè®® |

### 2.2 OpenIM æ¶æ„åˆ†æ

**é¡¹ç›®åœ°å€**: https://github.com/openimsdk/open-im-server

**æ¶æ„ç‰¹ç‚¹ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Client SDK                           â”‚
â”‚         (iOS / Android / Web / Flutter / Electron)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      msg_gateway                            â”‚
â”‚                    (WebSocketæ¥å…¥å±‚)                         â”‚
â”‚              ws://xxx:10001 | wss://xxx/msg_gateway          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        API Server                           â”‚
â”‚                    http://xxx:10002/api                     â”‚
â”‚    (ç”¨æˆ·ç®¡ç†/ç¾¤ç»„ç®¡ç†/å¥½å‹å…³ç³»/æ¶ˆæ¯å†å²ç­‰REST API)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     RPC Services (gRPC)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   User   â”‚ â”‚  Friend  â”‚ â”‚  Group   â”‚ â”‚ Message  â”‚       â”‚
â”‚  â”‚ Service  â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Storage                              â”‚
â”‚     MySQL (ä¸šåŠ¡æ•°æ®) + MongoDB (æ¶ˆæ¯) + Redis (ç¼“å­˜/çŠ¶æ€)    â”‚
â”‚                    + Kafka (æ¶ˆæ¯é˜Ÿåˆ—)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- âœ… å•èŠ/ç¾¤èŠæ¶ˆæ¯
- âœ… ç¾¤ç»„ç®¡ç†ï¼ˆåˆ›å»º/åŠ å…¥/é€€å‡º/è¸¢äºº/ç®¡ç†å‘˜ï¼‰
- âœ… å¥½å‹å…³ç³»ç®¡ç†
- âœ… æ¶ˆæ¯å·²è¯»å›æ‰§
- âœ… æ¶ˆæ¯æ’¤å›
- âœ… ç¦»çº¿æ¶ˆæ¯æ¨é€ (APNs/FCM)
- âœ… å¤šç«¯åŒæ­¥
- âœ… å®Œæ•´çš„å®¢æˆ·ç«¯SDK (iOS/Android/Web/Flutter/Electron)

**SDKåˆå§‹åŒ–ç¤ºä¾‹ï¼š**
```javascript
// Web SDK
const config = {
  platformID: 5,  // Web
  apiAddr: 'http://xxx:10002/api',
  wsAddr: 'ws://xxx:10001/msg_gateway',
};
IMSDK.init(config);
```

```swift
// iOS SDK
let config = OIMInitConfig()
config.platformID = .iOS
config.apiAddr = "http://xxx:10002/api"
config.wsAddr = "ws://xxx:10001/msg_gateway"
OIMManager.manager.initSDK(with: config)
```

### 2.3 WuKongIM æ¶æ„åˆ†æ

**é¡¹ç›®åœ°å€**: https://github.com/WuKongIM/WuKongIM

**æ¶æ„ç‰¹ç‚¹ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Client SDK                           â”‚
â”‚              (Web / iOS / Android / Flutter)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                 â”‚
     TCP:5100                           WS:5200
            â”‚                                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       WuKongIM Server                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Connect Layer                     â”‚   â”‚
â”‚  â”‚          (TCP Handler + WebSocket Handler)          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Channel Layer                     â”‚   â”‚
â”‚  â”‚        (æ¶ˆæ¯è·¯ç”±/é¢‘é“ç®¡ç†/è®¢é˜…å‘å¸ƒ)                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Storage Layer                     â”‚   â”‚
â”‚  â”‚              (è‡ªç ”å­˜å‚¨å¼•æ“/Slotåˆ†ç‰‡)                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                         API:5001
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Business Server                          â”‚
â”‚              (å”åƒ§å¨å¨ - ä¸šåŠ¡é€»è¾‘æœåŠ¡)                       â”‚
â”‚         ç”¨æˆ·ç®¡ç†/ç¾¤ç»„ç®¡ç†/å¥½å‹å…³ç³»/æ¶ˆæ¯å­˜å‚¨ç­‰                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒç‰¹ç‚¹ï¼š**
- **åŒåè®®æ”¯æŒ**ï¼šåŒæ—¶æ”¯æŒTCP (ç«¯å£5100) å’Œ WebSocket (ç«¯å£5200)
- **è‡ªç ”åè®®**ï¼šé«˜æ•ˆçš„äºŒè¿›åˆ¶åè®® + JSON-RPC
- **åˆ†å¸ƒå¼æ¶æ„**ï¼šæ”¯æŒé›†ç¾¤éƒ¨ç½²ï¼ŒSlotåˆ†ç‰‡
- **é«˜æ€§èƒ½**ï¼šå•æœºæ”¯æŒç™¾ä¸‡è¿æ¥

**åè®®æ ¼å¼ï¼š**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Packet Type (0.5 byte) â”‚ Flag (0.5 byte) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Remaining Length (å˜é•¿)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Payload                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¶ˆæ¯ç±»å‹ï¼š
- CONNECT (1): è¿æ¥è®¤è¯
- CONNACK (2): è¿æ¥ç¡®è®¤
- SEND (3): å‘é€æ¶ˆæ¯
- SENDACK (4): å‘é€ç¡®è®¤
- RECV (5): æ¥æ”¶æ¶ˆæ¯
- RECVACK (6): æ¥æ”¶ç¡®è®¤
- PING (7): å¿ƒè·³è¯·æ±‚
- PONG (8): å¿ƒè·³å“åº”
- DISCONNECT (9): æ–­å¼€è¿æ¥
```

**SDKä½¿ç”¨ç¤ºä¾‹ï¼š**
```javascript
// Web SDK
import { WKIM, WKIMEvent, WKIMChannelType } from 'easyjssdk';

const im = WKIM.init("ws://your-server.com:5200", {
  uid: "user123",
  token: "your_token"
});

// ç›‘å¬æ¶ˆæ¯
im.on(WKIMEvent.Message, (message) => {
  console.log("æ”¶åˆ°æ¶ˆæ¯:", message);
});

// å‘é€æ¶ˆæ¯
await im.send("friend_id", WKIMChannelType.Person, {
  type: 1,
  content: "Hello!"
});
```

```swift
// iOS SDK
let config = WuKongConfig(
    serverUrl: "ws://your-server.com:5200",
    uid: "user123",
    token: "your_token"
)
let easySDK = WuKongEasySDK(config: config)

// ç›‘å¬æ¶ˆæ¯
easySDK.onMessage { message in
    print("æ”¶åˆ°æ¶ˆæ¯:", message)
}

// å‘é€æ¶ˆæ¯
try await easySDK.send(
    channelId: "friend_id",
    channelType: .person,
    payload: MessagePayload(type: 1, content: "Hello!")
)
```

### 2.4 Rocket.Chat æ¶æ„åˆ†æ

**é¡¹ç›®åœ°å€**: https://github.com/RocketChat/Rocket.Chat

**æ¶æ„ç‰¹ç‚¹ï¼š**
- åŸºäº Meteor æ¡†æ¶
- ä½¿ç”¨ DDP (Distributed Data Protocol) å®æ—¶åè®®
- MongoDB å­˜å‚¨
- REST API + Realtime API (WebSocket)

**APIç»“æ„ï¼š**
```
Rocket.Chat APIs:
â”œâ”€â”€ REST API (HTTP)
â”‚   â”œâ”€â”€ /api/v1/users.*
â”‚   â”œâ”€â”€ /api/v1/groups.*
â”‚   â”œâ”€â”€ /api/v1/channels.*
â”‚   â””â”€â”€ /api/v1/chat.*
â”‚
â”œâ”€â”€ Realtime API (WebSocket)
â”‚   â”œâ”€â”€ Method Calls (RPC)
â”‚   â””â”€â”€ Subscriptions (Pub/Sub)
â”‚
â””â”€â”€ Livechat Widget API
```

**WebSocketè¿æ¥ï¼š**
```javascript
// è¿æ¥åˆ°Rocket.Chat WebSocket
const ws = new WebSocket('wss://your-server.com/websocket');

// å‘é€è¿æ¥æ¶ˆæ¯
ws.send(JSON.stringify({
  msg: 'connect',
  version: '1',
  support: ['1']
}));

// å¿ƒè·³å“åº”
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.msg === 'ping') {
    ws.send(JSON.stringify({ msg: 'pong' }));
  }
};
```

### 2.5 ä¸ç°æœ‰æ–¹æ¡ˆå¯¹æ¯”

| åŠŸèƒ½ | blog.mdæ–¹æ¡ˆ | OpenIM | WuKongIM | Rocket.Chat |
|------|-------------|--------|----------|-------------|
| **åè®®** | WebSocket | WebSocket | TCP + WebSocket | WebSocket (DDP) |
| **æ¶ˆæ¯æ ¼å¼** | JSON | Protobuf | è‡ªç ”äºŒè¿›åˆ¶ | EJSON |
| **å•èŠ** | âœ… | âœ… | âœ… | âœ… |
| **ç¾¤èŠ** | âœ… åŸºç¡€ | âœ… å®Œæ•´ | âœ… å®Œæ•´ | âœ… å®Œæ•´ |
| **ç¾¤æˆå‘˜é€šçŸ¥** | âŒ | âœ… | âœ… | âœ… |
| **ç¾¤èµ„æ–™ç®¡ç†** | âŒ | âœ… | âœ… | âœ… |
| **ç¦»çº¿æ¶ˆæ¯å­˜å‚¨** | âœ… ç®€å• | âœ… | âœ… | âœ… |
| **ç¦»çº¿æ¨é€** | âŒ | âœ… APNs/FCM | âœ… | âœ… |
| **æ¶ˆæ¯å·²è¯»å›æ‰§** | âŒ | âœ… | âœ… | âœ… |
| **æ¶ˆæ¯æ’¤å›** | âŒ | âœ… | âœ… | âœ… |
| **è·¨èŠ‚ç‚¹è·¯ç”±** | âŒ ä»…æ³¨é‡Š | âœ… Kafka | âœ… åˆ†å¸ƒå¼ | âœ… |
| **å®¢æˆ·ç«¯SDK** | âŒ | âœ… å…¨å¹³å° | âœ… å…¨å¹³å° | âœ… å…¨å¹³å° |
| **éƒ¨ç½²å¤æ‚åº¦** | ä½ | é«˜ | ä¸­ | ä¸­ |
| **é€‚ç”¨è§„æ¨¡** | åƒäºº | ç™¾ä¸‡çº§ | ç™¾ä¸‡çº§ | ä¸‡äººçº§ |

### 2.6 å­¦ä¹ å»ºè®®

1. **åˆå­¦è€…/å°é¡¹ç›®**ï¼šå¯ä»¥ä» `blog.md` æ–¹æ¡ˆå¼€å§‹ï¼Œç†è§£IMåŸºæœ¬åŸç†
2. **ä¸­å‹é¡¹ç›®**ï¼šå‚è€ƒ WuKongIM çš„æ¶æ„è®¾è®¡ï¼Œå­¦ä¹ åŒåè®®æ”¯æŒå’Œåˆ†å¸ƒå¼è®¾è®¡
3. **ä¼ä¸šçº§é¡¹ç›®**ï¼šå‚è€ƒ OpenIM çš„å®Œæ•´åŠŸèƒ½å®ç°ï¼Œç‰¹åˆ«æ˜¯SDKè®¾è®¡
4. **éœ€è¦UIçš„é¡¹ç›®**ï¼šç›´æ¥ä½¿ç”¨ Rocket.Chatï¼ŒåŠŸèƒ½å®Œæ•´ä¸”æœ‰ç°æˆUI

### 2.7 æ¨èçš„å¼€æºé¡¹ç›®æ¸…å•

| é¡¹ç›® | GitHubåœ°å€ | æ¨èæŒ‡æ•° | è¯´æ˜ |
|------|-----------|---------|------|
| **OpenIM Server** | github.com/openimsdk/open-im-server | â­â­â­â­â­ | æœ€å®Œæ•´çš„å¼€æºIMï¼Œä¼ä¸šçº§ |
| **OpenIM SDK (Web)** | github.com/openimsdk/openim-sdk-js | â­â­â­â­â­ | Web/Electron SDK |
| **OpenIM SDK (iOS)** | github.com/openimsdk/open-im-sdk-ios | â­â­â­â­â­ | iOSåŸç”ŸSDK |
| **OpenIM SDK (Android)** | github.com/openimsdk/open-im-sdk-android | â­â­â­â­â­ | AndroidåŸç”ŸSDK |
| **WuKongIM** | github.com/WuKongIM/WuKongIM | â­â­â­â­ | é«˜æ€§èƒ½IMæ ¸å¿ƒ |
| **å”åƒ§å¨å¨** | github.com/TangSengDaoDao/TangSengDaoDaoServer | â­â­â­â­ | WuKongIMçš„ä¸šåŠ¡å±‚ |
| **Rocket.Chat** | github.com/RocketChat/Rocket.Chat | â­â­â­â­ | å®Œæ•´IMè§£å†³æ–¹æ¡ˆ |
| **Matrix Synapse** | github.com/matrix-org/synapse | â­â­â­ | å»ä¸­å¿ƒåŒ–IM |

---

---

## å››ã€æ¶ˆæ¯åè®®æ‰©å±•

### 1.1 æ‰©å±•æ¶ˆæ¯ç±»å‹å®šä¹‰

```protobuf
syntax = "proto3";
package im;

// æ¶ˆæ¯ç±»å‹æšä¸¾
enum MessageType {
    // åŸºç¡€æ¶ˆæ¯ (1-9)
    MSG_SINGLE_CHAT = 1;      // å•èŠæ¶ˆæ¯
    MSG_GROUP_CHAT = 2;       // ç¾¤èŠæ¶ˆæ¯
    MSG_SYSTEM = 3;           // ç³»ç»Ÿé€šçŸ¥
    
    // ç¾¤ç»„äº‹ä»¶ (10-19)
    MSG_GROUP_CREATED = 10;       // ç¾¤ç»„åˆ›å»º
    MSG_GROUP_MEMBER_JOIN = 11;   // æˆå‘˜åŠ å…¥
    MSG_GROUP_MEMBER_LEAVE = 12;  // æˆå‘˜ä¸»åŠ¨é€€å‡º
    MSG_GROUP_MEMBER_KICKED = 13; // æˆå‘˜è¢«è¸¢å‡º
    MSG_GROUP_DISMISSED = 14;     // ç¾¤ç»„è§£æ•£
    MSG_GROUP_INFO_UPDATE = 15;   // ç¾¤èµ„æ–™å˜æ›´
    MSG_GROUP_ADMIN_CHANGE = 16;  // ç®¡ç†å‘˜å˜æ›´
    MSG_GROUP_MUTE = 17;          // ç¦è¨€é€šçŸ¥
    MSG_GROUP_TRANSFER = 18;      // ç¾¤ä¸»è½¬è®©
    
    // æ¶ˆæ¯çŠ¶æ€ (20-29)
    MSG_ACK = 20;                 // æ¶ˆæ¯ç¡®è®¤
    MSG_READ_RECEIPT = 21;        // å·²è¯»å›æ‰§
    MSG_REVOKE = 22;              // æ¶ˆæ¯æ’¤å›
    MSG_TYPING = 23;              // æ­£åœ¨è¾“å…¥
    
    // ç³»ç»Ÿæ¶ˆæ¯ (90-99)
    MSG_HEARTBEAT = 99;           // å¿ƒè·³
}

// ä¸»æ¶ˆæ¯ç»“æ„
message Message {
    string message_id = 1;        // æ¶ˆæ¯ID (UUID)
    MessageType type = 2;         // æ¶ˆæ¯ç±»å‹
    string from = 3;              // å‘é€è€…ID
    string to = 4;                // æ¥æ”¶è€…IDæˆ–ç¾¤ç»„ID
    bytes content = 5;            // æ¶ˆæ¯å†…å®¹ (JSONåºåˆ—åŒ–)
    int64 timestamp = 6;          // æœåŠ¡å™¨æ—¶é—´æˆ³
    int64 client_timestamp = 7;   // å®¢æˆ·ç«¯æ—¶é—´æˆ³
    int32 qos = 8;                // æœåŠ¡è´¨é‡: 0-æœ€å¤šä¸€æ¬¡ 1-è‡³å°‘ä¸€æ¬¡
    string conversation_id = 9;   // ä¼šè¯ID
    int64 seq = 10;               // æ¶ˆæ¯åºåˆ—å·
}

// ç¾¤ç»„äº‹ä»¶å†…å®¹
message GroupEventContent {
    string group_id = 1;
    string operator_id = 2;       // æ“ä½œè€…ID
    repeated string target_ids = 3; // ç›®æ ‡ç”¨æˆ·IDåˆ—è¡¨
    map<string, string> extra = 4;  // æ‰©å±•ä¿¡æ¯
}

// ç¾¤èµ„æ–™å˜æ›´å†…å®¹
message GroupInfoUpdateContent {
    string group_id = 1;
    string operator_id = 2;
    string field = 3;             // å˜æ›´å­—æ®µ: name/avatar/announcement/...
    string old_value = 4;
    string new_value = 5;
}

// æ¶ˆæ¯æ’¤å›å†…å®¹
message RevokeContent {
    string target_message_id = 1;
    string conversation_id = 2;
}

// å·²è¯»å›æ‰§å†…å®¹
message ReadReceiptContent {
    string conversation_id = 1;
    string last_read_message_id = 2;
    int64 last_read_seq = 3;
}
```

### 1.2 Go ç»“æ„ä½“å®šä¹‰

```go
// message_types.go

package model

import "time"

// MessageType æ¶ˆæ¯ç±»å‹
type MessageType int

const (
    // åŸºç¡€æ¶ˆæ¯
    MsgSingleChat MessageType = 1
    MsgGroupChat  MessageType = 2
    MsgSystem     MessageType = 3

    // ç¾¤ç»„äº‹ä»¶
    MsgGroupCreated      MessageType = 10
    MsgGroupMemberJoin   MessageType = 11
    MsgGroupMemberLeave  MessageType = 12
    MsgGroupMemberKicked MessageType = 13
    MsgGroupDismissed    MessageType = 14
    MsgGroupInfoUpdate   MessageType = 15
    MsgGroupAdminChange  MessageType = 16
    MsgGroupMute         MessageType = 17
    MsgGroupTransfer     MessageType = 18

    // æ¶ˆæ¯çŠ¶æ€
    MsgAck         MessageType = 20
    MsgReadReceipt MessageType = 21
    MsgRevoke      MessageType = 22
    MsgTyping      MessageType = 23

    // ç³»ç»Ÿæ¶ˆæ¯
    MsgHeartbeat MessageType = 99
)

// Message æ¶ˆæ¯ä¸»ä½“
type Message struct {
    MessageID       string      `json:"message_id"`
    Type            MessageType `json:"type"`
    From            string      `json:"from"`
    To              string      `json:"to"`
    Content         interface{} `json:"content"`
    Timestamp       int64       `json:"timestamp"`
    ClientTimestamp int64       `json:"client_timestamp,omitempty"`
    QoS             int         `json:"qos"`
    ConversationID  string      `json:"conversation_id"`
    Seq             int64       `json:"seq"`
}

// GroupEventContent ç¾¤ç»„äº‹ä»¶å†…å®¹
type GroupEventContent struct {
    GroupID    string            `json:"group_id"`
    OperatorID string            `json:"operator_id"`
    TargetIDs  []string          `json:"target_ids,omitempty"`
    Extra      map[string]string `json:"extra,omitempty"`
}

// GroupInfoUpdateContent ç¾¤èµ„æ–™å˜æ›´å†…å®¹
type GroupInfoUpdateContent struct {
    GroupID    string `json:"group_id"`
    OperatorID string `json:"operator_id"`
    Field      string `json:"field"`
    OldValue   string `json:"old_value"`
    NewValue   string `json:"new_value"`
}
```

---

## äº”ã€ç¾¤ç»„ç®¡ç†ç³»ç»Ÿ

### 2.1 ç¾¤ç»„æ•°æ®æ¨¡å‹

```go
// group.go

package model

import "time"

// GroupRole ç¾¤æˆå‘˜è§’è‰²
type GroupRole int

const (
    RoleMember GroupRole = 0  // æ™®é€šæˆå‘˜
    RoleAdmin  GroupRole = 1  // ç®¡ç†å‘˜
    RoleOwner  GroupRole = 2  // ç¾¤ä¸»
)

// Group ç¾¤ç»„ä¿¡æ¯
type Group struct {
    GroupID      string    `json:"group_id" gorm:"primaryKey;type:varchar(64)"`
    Name         string    `json:"name" gorm:"type:varchar(128)"`
    Avatar       string    `json:"avatar" gorm:"type:varchar(512)"`
    Announcement string    `json:"announcement" gorm:"type:text"`
    Description  string    `json:"description" gorm:"type:varchar(512)"`
    OwnerID      string    `json:"owner_id" gorm:"type:varchar(64);index"`
    MaxMembers   int       `json:"max_members" gorm:"default:500"`
    MemberCount  int       `json:"member_count" gorm:"default:0"`
    MuteAll      bool      `json:"mute_all" gorm:"default:false"` // å…¨å‘˜ç¦è¨€
    JoinMode     int       `json:"join_mode" gorm:"default:0"`    // 0-è‡ªç”±åŠ å…¥ 1-éœ€å®¡æ‰¹ 2-ç¦æ­¢åŠ å…¥
    Status       int       `json:"status" gorm:"default:1"`       // 1-æ­£å¸¸ 0-å·²è§£æ•£
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}

// GroupMember ç¾¤æˆå‘˜
type GroupMember struct {
    ID        uint      `json:"id" gorm:"primaryKey;autoIncrement"`
    GroupID   string    `json:"group_id" gorm:"type:varchar(64);uniqueIndex:idx_group_user"`
    UserID    string    `json:"user_id" gorm:"type:varchar(64);uniqueIndex:idx_group_user;index"`
    Role      GroupRole `json:"role" gorm:"default:0"`
    Nickname  string    `json:"nickname" gorm:"type:varchar(64)"` // ç¾¤æ˜µç§°
    MuteUntil int64     `json:"mute_until" gorm:"default:0"`      // ç¦è¨€æˆªæ­¢æ—¶é—´æˆ³
    JoinedAt  time.Time `json:"joined_at"`
    InviterID string    `json:"inviter_id" gorm:"type:varchar(64)"` // é‚€è¯·äºº
}

// TableName æŒ‡å®šè¡¨å
func (Group) TableName() string {
    return "groups"
}

func (GroupMember) TableName() string {
    return "group_members"
}
```

### 2.2 ç¾¤ç»„æœåŠ¡æ¥å£

```go
// group_service.go

package service

import (
    "context"
    "errors"
    "time"
    
    "github.com/google/uuid"
)

var (
    ErrGroupNotFound     = errors.New("group not found")
    ErrNotGroupMember    = errors.New("not a group member")
    ErrNotGroupOwner     = errors.New("not group owner")
    ErrNotGroupAdmin     = errors.New("not group admin")
    ErrGroupFull         = errors.New("group is full")
    ErrAlreadyInGroup    = errors.New("already in group")
    ErrCannotKickOwner   = errors.New("cannot kick group owner")
)

// GroupService ç¾¤ç»„æœåŠ¡æ¥å£
type GroupService interface {
    // ç¾¤ç»„æ“ä½œ
    CreateGroup(ctx context.Context, req *CreateGroupRequest) (*Group, error)
    DismissGroup(ctx context.Context, groupID, operatorID string) error
    GetGroupInfo(ctx context.Context, groupID string) (*Group, error)
    UpdateGroupInfo(ctx context.Context, req *UpdateGroupRequest) error
    
    // æˆå‘˜ç®¡ç†
    JoinGroup(ctx context.Context, groupID, userID string, inviterID string) error
    LeaveGroup(ctx context.Context, groupID, userID string) error
    KickMember(ctx context.Context, groupID, operatorID string, targetIDs []string) error
    GetGroupMembers(ctx context.Context, groupID string, page, pageSize int) ([]*GroupMember, int, error)
    
    // ç®¡ç†å‘˜æ“ä½œ
    SetAdmin(ctx context.Context, groupID, operatorID, targetID string, isAdmin bool) error
    TransferOwner(ctx context.Context, groupID, ownerID, newOwnerID string) error
    MuteMember(ctx context.Context, groupID, operatorID, targetID string, duration time.Duration) error
    SetMuteAll(ctx context.Context, groupID, operatorID string, muteAll bool) error
    
    // æŸ¥è¯¢
    GetUserGroups(ctx context.Context, userID string) ([]*Group, error)
    IsMember(ctx context.Context, groupID, userID string) (bool, error)
    GetMemberRole(ctx context.Context, groupID, userID string) (GroupRole, error)
}

// CreateGroupRequest åˆ›å»ºç¾¤ç»„è¯·æ±‚
type CreateGroupRequest struct {
    OwnerID     string   `json:"owner_id"`
    Name        string   `json:"name"`
    Avatar      string   `json:"avatar"`
    Description string   `json:"description"`
    MemberIDs   []string `json:"member_ids"` // åˆå§‹æˆå‘˜
}

// UpdateGroupRequest æ›´æ–°ç¾¤ç»„è¯·æ±‚
type UpdateGroupRequest struct {
    GroupID      string `json:"group_id"`
    OperatorID   string `json:"operator_id"`
    Name         *string `json:"name,omitempty"`
    Avatar       *string `json:"avatar,omitempty"`
    Announcement *string `json:"announcement,omitempty"`
    Description  *string `json:"description,omitempty"`
    JoinMode     *int    `json:"join_mode,omitempty"`
}
```

### 2.3 ç¾¤ç»„æœåŠ¡å®ç°

```go
// group_service_impl.go

package service

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/go-redis/redis/v8"
    "github.com/google/uuid"
    "gorm.io/gorm"
)

type groupServiceImpl struct {
    db          *gorm.DB
    redis       *redis.Client
    msgDispatcher MessageDispatcher  // æ¶ˆæ¯åˆ†å‘å™¨
}

func NewGroupService(db *gorm.DB, redis *redis.Client, dispatcher MessageDispatcher) GroupService {
    return &groupServiceImpl{
        db:            db,
        redis:         redis,
        msgDispatcher: dispatcher,
    }
}

// CreateGroup åˆ›å»ºç¾¤ç»„
func (s *groupServiceImpl) CreateGroup(ctx context.Context, req *CreateGroupRequest) (*Group, error) {
    groupID := uuid.New().String()
    now := time.Now()
    
    group := &Group{
        GroupID:     groupID,
        Name:        req.Name,
        Avatar:      req.Avatar,
        Description: req.Description,
        OwnerID:     req.OwnerID,
        MaxMembers:  500,
        MemberCount: 1,
        Status:      1,
        CreatedAt:   now,
        UpdatedAt:   now,
    }
    
    // å¼€å¯äº‹åŠ¡
    err := s.db.Transaction(func(tx *gorm.DB) error {
        // åˆ›å»ºç¾¤ç»„
        if err := tx.Create(group).Error; err != nil {
            return err
        }
        
        // æ·»åŠ ç¾¤ä¸»ä¸ºæˆå‘˜
        owner := &GroupMember{
            GroupID:  groupID,
            UserID:   req.OwnerID,
            Role:     RoleOwner,
            JoinedAt: now,
        }
        if err := tx.Create(owner).Error; err != nil {
            return err
        }
        
        // æ·»åŠ åˆå§‹æˆå‘˜
        for _, memberID := range req.MemberIDs {
            if memberID == req.OwnerID {
                continue
            }
            member := &GroupMember{
                GroupID:   groupID,
                UserID:    memberID,
                Role:      RoleMember,
                JoinedAt:  now,
                InviterID: req.OwnerID,
            }
            if err := tx.Create(member).Error; err != nil {
                return err
            }
            group.MemberCount++
        }
        
        // æ›´æ–°æˆå‘˜æ•°
        return tx.Model(group).Update("member_count", group.MemberCount).Error
    })
    
    if err != nil {
        return nil, err
    }
    
    // åŒæ­¥åˆ°Redis
    s.syncGroupMembersToRedis(ctx, groupID)
    
    // å‘é€ç¾¤åˆ›å»ºé€šçŸ¥
    s.notifyGroupEvent(ctx, groupID, MsgGroupCreated, req.OwnerID, req.MemberIDs, nil)
    
    return group, nil
}

// JoinGroup åŠ å…¥ç¾¤ç»„
func (s *groupServiceImpl) JoinGroup(ctx context.Context, groupID, userID, inviterID string) error {
    // æ£€æŸ¥ç¾¤æ˜¯å¦å­˜åœ¨
    group, err := s.GetGroupInfo(ctx, groupID)
    if err != nil {
        return err
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²æ˜¯æˆå‘˜
    isMember, _ := s.IsMember(ctx, groupID, userID)
    if isMember {
        return ErrAlreadyInGroup
    }
    
    // æ£€æŸ¥ç¾¤æ˜¯å¦å·²æ»¡
    if group.MemberCount >= group.MaxMembers {
        return ErrGroupFull
    }
    
    // æ·»åŠ æˆå‘˜
    member := &GroupMember{
        GroupID:   groupID,
        UserID:    userID,
        Role:      RoleMember,
        JoinedAt:  time.Now(),
        InviterID: inviterID,
    }
    
    err = s.db.Transaction(func(tx *gorm.DB) error {
        if err := tx.Create(member).Error; err != nil {
            return err
        }
        return tx.Model(&Group{}).Where("group_id = ?", groupID).
            Update("member_count", gorm.Expr("member_count + 1")).Error
    })
    
    if err != nil {
        return err
    }
    
    // åŒæ­¥åˆ°Redis
    s.redis.SAdd(ctx, "group:members:"+groupID, userID)
    
    // å‘é€æˆå‘˜åŠ å…¥é€šçŸ¥ç»™æ‰€æœ‰ç¾¤æˆå‘˜
    s.notifyGroupEvent(ctx, groupID, MsgGroupMemberJoin, inviterID, []string{userID}, nil)
    
    return nil
}

// LeaveGroup é€€å‡ºç¾¤ç»„
func (s *groupServiceImpl) LeaveGroup(ctx context.Context, groupID, userID string) error {
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤æˆå‘˜
    role, err := s.GetMemberRole(ctx, groupID, userID)
    if err != nil {
        return ErrNotGroupMember
    }
    
    // ç¾¤ä¸»ä¸èƒ½ç›´æ¥é€€å‡ºï¼Œéœ€è¦å…ˆè½¬è®©
    if role == RoleOwner {
        return errors.New("owner cannot leave group directly, please transfer ownership first")
    }
    
    err = s.db.Transaction(func(tx *gorm.DB) error {
        // åˆ é™¤æˆå‘˜è®°å½•
        if err := tx.Where("group_id = ? AND user_id = ?", groupID, userID).
            Delete(&GroupMember{}).Error; err != nil {
            return err
        }
        // æ›´æ–°æˆå‘˜æ•°
        return tx.Model(&Group{}).Where("group_id = ?", groupID).
            Update("member_count", gorm.Expr("member_count - 1")).Error
    })
    
    if err != nil {
        return err
    }
    
    // åŒæ­¥åˆ°Redis
    s.redis.SRem(ctx, "group:members:"+groupID, userID)
    
    // å‘é€æˆå‘˜é€€å‡ºé€šçŸ¥
    s.notifyGroupEvent(ctx, groupID, MsgGroupMemberLeave, userID, []string{userID}, nil)
    
    return nil
}

// KickMember è¸¢å‡ºæˆå‘˜
func (s *groupServiceImpl) KickMember(ctx context.Context, groupID, operatorID string, targetIDs []string) error {
    // æ£€æŸ¥æ“ä½œè€…æƒé™
    operatorRole, err := s.GetMemberRole(ctx, groupID, operatorID)
    if err != nil {
        return ErrNotGroupMember
    }
    
    if operatorRole < RoleAdmin {
        return ErrNotGroupAdmin
    }
    
    // è¿‡æ»¤ä¸èƒ½è¸¢çš„äºº
    var validTargets []string
    for _, targetID := range targetIDs {
        targetRole, err := s.GetMemberRole(ctx, groupID, targetID)
        if err != nil {
            continue
        }
        // ä¸èƒ½è¸¢ç¾¤ä¸»ï¼Œç®¡ç†å‘˜åªèƒ½è¢«ç¾¤ä¸»è¸¢
        if targetRole == RoleOwner {
            continue
        }
        if targetRole == RoleAdmin && operatorRole != RoleOwner {
            continue
        }
        validTargets = append(validTargets, targetID)
    }
    
    if len(validTargets) == 0 {
        return nil
    }
    
    err = s.db.Transaction(func(tx *gorm.DB) error {
        if err := tx.Where("group_id = ? AND user_id IN ?", groupID, validTargets).
            Delete(&GroupMember{}).Error; err != nil {
            return err
        }
        return tx.Model(&Group{}).Where("group_id = ?", groupID).
            Update("member_count", gorm.Expr("member_count - ?", len(validTargets))).Error
    })
    
    if err != nil {
        return err
    }
    
    // åŒæ­¥åˆ°Redis
    for _, targetID := range validTargets {
        s.redis.SRem(ctx, "group:members:"+groupID, targetID)
    }
    
    // å‘é€è¢«è¸¢é€šçŸ¥
    s.notifyGroupEvent(ctx, groupID, MsgGroupMemberKicked, operatorID, validTargets, nil)
    
    return nil
}

// UpdateGroupInfo æ›´æ–°ç¾¤èµ„æ–™
func (s *groupServiceImpl) UpdateGroupInfo(ctx context.Context, req *UpdateGroupRequest) error {
    // æ£€æŸ¥æ“ä½œè€…æƒé™
    role, err := s.GetMemberRole(ctx, req.GroupID, req.OperatorID)
    if err != nil {
        return ErrNotGroupMember
    }
    if role < RoleAdmin {
        return ErrNotGroupAdmin
    }
    
    // è·å–æ—§å€¼ç”¨äºé€šçŸ¥
    oldGroup, err := s.GetGroupInfo(ctx, req.GroupID)
    if err != nil {
        return err
    }
    
    updates := make(map[string]interface{})
    notifications := []struct {
        field    string
        oldValue string
        newValue string
    }{}
    
    if req.Name != nil && *req.Name != oldGroup.Name {
        updates["name"] = *req.Name
        notifications = append(notifications, struct {
            field    string
            oldValue string
            newValue string
        }{"name", oldGroup.Name, *req.Name})
    }
    if req.Avatar != nil && *req.Avatar != oldGroup.Avatar {
        updates["avatar"] = *req.Avatar
        notifications = append(notifications, struct {
            field    string
            oldValue string
            newValue string
        }{"avatar", oldGroup.Avatar, *req.Avatar})
    }
    if req.Announcement != nil && *req.Announcement != oldGroup.Announcement {
        updates["announcement"] = *req.Announcement
        notifications = append(notifications, struct {
            field    string
            oldValue string
            newValue string
        }{"announcement", oldGroup.Announcement, *req.Announcement})
    }
    if req.Description != nil && *req.Description != oldGroup.Description {
        updates["description"] = *req.Description
    }
    
    if len(updates) == 0 {
        return nil
    }
    
    updates["updated_at"] = time.Now()
    
    if err := s.db.Model(&Group{}).Where("group_id = ?", req.GroupID).
        Updates(updates).Error; err != nil {
        return err
    }
    
    // å‘é€ç¾¤èµ„æ–™å˜æ›´é€šçŸ¥
    for _, n := range notifications {
        extra := map[string]string{
            "field":     n.field,
            "old_value": n.oldValue,
            "new_value": n.newValue,
        }
        s.notifyGroupEvent(ctx, req.GroupID, MsgGroupInfoUpdate, req.OperatorID, nil, extra)
    }
    
    return nil
}

// notifyGroupEvent å‘é€ç¾¤äº‹ä»¶é€šçŸ¥
func (s *groupServiceImpl) notifyGroupEvent(
    ctx context.Context,
    groupID string,
    msgType MessageType,
    operatorID string,
    targetIDs []string,
    extra map[string]string,
) {
    content := &GroupEventContent{
        GroupID:    groupID,
        OperatorID: operatorID,
        TargetIDs:  targetIDs,
        Extra:      extra,
    }
    
    msg := &Message{
        MessageID:      uuid.New().String(),
        Type:           msgType,
        From:           "system",
        To:             groupID,
        Content:        content,
        Timestamp:      time.Now().UnixMilli(),
        ConversationID: "group:" + groupID,
    }
    
    // è·å–æ‰€æœ‰ç¾¤æˆå‘˜å¹¶æ¨é€
    memberIDs, _ := s.redis.SMembers(ctx, "group:members:"+groupID).Result()
    
    // å¯¹äºè¢«è¸¢çš„äººä¹Ÿè¦å‘é€é€šçŸ¥
    allReceivers := append(memberIDs, targetIDs...)
    allReceivers = uniqueStrings(allReceivers)
    
    s.msgDispatcher.DispatchToUsers(ctx, msg, allReceivers)
}

// syncGroupMembersToRedis åŒæ­¥ç¾¤æˆå‘˜åˆ°Redis
func (s *groupServiceImpl) syncGroupMembersToRedis(ctx context.Context, groupID string) error {
    var members []GroupMember
    if err := s.db.Where("group_id = ?", groupID).Find(&members).Error; err != nil {
        return err
    }
    
    key := "group:members:" + groupID
    s.redis.Del(ctx, key)
    
    memberIDs := make([]interface{}, len(members))
    for i, m := range members {
        memberIDs[i] = m.UserID
    }
    
    if len(memberIDs) > 0 {
        s.redis.SAdd(ctx, key, memberIDs...)
    }
    
    return nil
}

// GetMemberRole è·å–æˆå‘˜è§’è‰²
func (s *groupServiceImpl) GetMemberRole(ctx context.Context, groupID, userID string) (GroupRole, error) {
    var member GroupMember
    err := s.db.Where("group_id = ? AND user_id = ?", groupID, userID).First(&member).Error
    if err != nil {
        return 0, ErrNotGroupMember
    }
    return member.Role, nil
}

// IsMember æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤æˆå‘˜
func (s *groupServiceImpl) IsMember(ctx context.Context, groupID, userID string) (bool, error) {
    // ä¼˜å…ˆä»RedisæŸ¥è¯¢
    exists, err := s.redis.SIsMember(ctx, "group:members:"+groupID, userID).Result()
    if err == nil {
        return exists, nil
    }
    
    // Redisä¸å¯ç”¨æ—¶ä»DBæŸ¥è¯¢
    var count int64
    err = s.db.Model(&GroupMember{}).Where("group_id = ? AND user_id = ?", groupID, userID).Count(&count).Error
    return count > 0, err
}

func uniqueStrings(input []string) []string {
    seen := make(map[string]bool)
    result := make([]string, 0, len(input))
    for _, s := range input {
        if !seen[s] {
            seen[s] = true
            result = append(result, s)
        }
    }
    return result
}
```

### 2.4 ç¾¤ç»„APIæ¥å£

```go
// group_handler.go

package handler

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
)

type GroupHandler struct {
    groupService GroupService
}

func NewGroupHandler(gs GroupService) *GroupHandler {
    return &GroupHandler{groupService: gs}
}

func (h *GroupHandler) RegisterRoutes(r *gin.RouterGroup) {
    group := r.Group("/group")
    {
        group.POST("/create", h.CreateGroup)
        group.POST("/join", h.JoinGroup)
        group.POST("/leave", h.LeaveGroup)
        group.POST("/kick", h.KickMember)
        group.GET("/info", h.GetGroupInfo)
        group.PUT("/info", h.UpdateGroupInfo)
        group.GET("/members", h.GetGroupMembers)
        group.POST("/admin/set", h.SetAdmin)
        group.POST("/transfer", h.TransferOwner)
        group.POST("/mute", h.MuteMember)
        group.POST("/mute-all", h.SetMuteAll)
    }
}

// CreateGroup åˆ›å»ºç¾¤ç»„
// POST /api/group/create
func (h *GroupHandler) CreateGroup(c *gin.Context) {
    userID := c.GetString("user_id") // ä»JWTä¸­è·å–
    
    var req struct {
        Name        string   `json:"name" binding:"required,max=64"`
        Avatar      string   `json:"avatar"`
        Description string   `json:"description"`
        MemberIDs   []string `json:"member_ids"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    group, err := h.groupService.CreateGroup(c.Request.Context(), &CreateGroupRequest{
        OwnerID:     userID,
        Name:        req.Name,
        Avatar:      req.Avatar,
        Description: req.Description,
        MemberIDs:   req.MemberIDs,
    })
    
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": group,
    })
}

// JoinGroup åŠ å…¥ç¾¤ç»„
// POST /api/group/join
func (h *GroupHandler) JoinGroup(c *gin.Context) {
    userID := c.GetString("user_id")
    
    var req struct {
        GroupID string `json:"group_id" binding:"required"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    err := h.groupService.JoinGroup(c.Request.Context(), req.GroupID, userID, "")
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success"})
}

// LeaveGroup é€€å‡ºç¾¤ç»„
// POST /api/group/leave
func (h *GroupHandler) LeaveGroup(c *gin.Context) {
    userID := c.GetString("user_id")
    
    var req struct {
        GroupID string `json:"group_id" binding:"required"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    err := h.groupService.LeaveGroup(c.Request.Context(), req.GroupID, userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success"})
}

// KickMember è¸¢å‡ºæˆå‘˜
// POST /api/group/kick
func (h *GroupHandler) KickMember(c *gin.Context) {
    userID := c.GetString("user_id")
    
    var req struct {
        GroupID   string   `json:"group_id" binding:"required"`
        TargetIDs []string `json:"target_ids" binding:"required,min=1"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    err := h.groupService.KickMember(c.Request.Context(), req.GroupID, userID, req.TargetIDs)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success"})
}

// GetGroupInfo è·å–ç¾¤ä¿¡æ¯
// GET /api/group/info?group_id=xxx
func (h *GroupHandler) GetGroupInfo(c *gin.Context) {
    groupID := c.Query("group_id")
    if groupID == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "group_id required"})
        return
    }
    
    group, err := h.groupService.GetGroupInfo(c.Request.Context(), groupID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": group,
    })
}

// UpdateGroupInfo æ›´æ–°ç¾¤ä¿¡æ¯
// PUT /api/group/info
func (h *GroupHandler) UpdateGroupInfo(c *gin.Context) {
    userID := c.GetString("user_id")
    
    var req UpdateGroupRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    req.OperatorID = userID
    
    err := h.groupService.UpdateGroupInfo(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success"})
}

// GetGroupMembers è·å–ç¾¤æˆå‘˜åˆ—è¡¨
// GET /api/group/members?group_id=xxx&page=1&page_size=20
func (h *GroupHandler) GetGroupMembers(c *gin.Context) {
    groupID := c.Query("group_id")
    page := c.DefaultQuery("page", "1")
    pageSize := c.DefaultQuery("page_size", "20")
    
    // ... å‚æ•°è½¬æ¢å’Œæ ¡éªŒ
    
    members, total, err := h.groupService.GetGroupMembers(
        c.Request.Context(), 
        groupID, 
        /* page */ 1, 
        /* pageSize */ 20,
    )
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": gin.H{
            "members": members,
            "total":   total,
        },
    })
}
```

---

## å…­ã€ç¦»çº¿æ¶ˆæ¯ä¸æ¨é€

### 3.1 ç¦»çº¿æ¶ˆæ¯å­˜å‚¨æœåŠ¡

```go
// offline_service.go

package service

import (
    "context"
    "encoding/json"
    "strconv"
    "time"
    
    "github.com/go-redis/redis/v8"
    "gorm.io/gorm"
)

const (
    offlineMessageExpire = 7 * 24 * time.Hour // ç¦»çº¿æ¶ˆæ¯ä¿ç•™7å¤©
    maxOfflineMessages   = 1000               // æ¯ä¸ªç”¨æˆ·æœ€å¤šå­˜å‚¨1000æ¡ç¦»çº¿æ¶ˆæ¯
)

// OfflineMessage ç¦»çº¿æ¶ˆæ¯å­˜å‚¨ç»“æ„
type OfflineMessage struct {
    ID             uint      `json:"id" gorm:"primaryKey;autoIncrement"`
    UserID         string    `json:"user_id" gorm:"type:varchar(64);index:idx_user_created"`
    MessageID      string    `json:"message_id" gorm:"type:varchar(64);uniqueIndex"`
    ConversationID string    `json:"conversation_id" gorm:"type:varchar(128);index"`
    Content        string    `json:"content" gorm:"type:text"`          // JSONåºåˆ—åŒ–çš„æ¶ˆæ¯å†…å®¹
    Pushed         bool      `json:"pushed" gorm:"default:false"`       // æ˜¯å¦å·²æ¨é€åˆ°APNs/FCM
    PushedAt       *time.Time `json:"pushed_at"`
    CreatedAt      time.Time `json:"created_at" gorm:"index:idx_user_created"`
    ExpireAt       time.Time `json:"expire_at" gorm:"index"`
}

// OfflineService ç¦»çº¿æ¶ˆæ¯æœåŠ¡
type OfflineService interface {
    // å­˜å‚¨ç¦»çº¿æ¶ˆæ¯
    SaveOfflineMessage(ctx context.Context, userID string, msg *Message) error
    
    // æ‹‰å–ç¦»çº¿æ¶ˆæ¯
    PullOfflineMessages(ctx context.Context, userID string, lastMsgID string, limit int) ([]*Message, error)
    
    // æ ‡è®°æ¶ˆæ¯ä¸ºå·²æ¨é€
    MarkAsPushed(ctx context.Context, messageIDs []string) error
    
    // åˆ é™¤å·²è¯»çš„ç¦»çº¿æ¶ˆæ¯
    DeleteOfflineMessages(ctx context.Context, userID string, messageIDs []string) error
    
    // è·å–æœªæ¨é€çš„æ¶ˆæ¯ï¼ˆä¾›æ¨é€æœåŠ¡ä½¿ç”¨ï¼‰
    GetUnpushedMessages(ctx context.Context, limit int) ([]*OfflineMessage, error)
    
    // æ¸…ç†è¿‡æœŸæ¶ˆæ¯
    CleanExpiredMessages(ctx context.Context) (int64, error)
}

type offlineServiceImpl struct {
    db    *gorm.DB
    redis *redis.Client
}

func NewOfflineService(db *gorm.DB, redis *redis.Client) OfflineService {
    return &offlineServiceImpl{db: db, redis: redis}
}

// SaveOfflineMessage å­˜å‚¨ç¦»çº¿æ¶ˆæ¯
func (s *offlineServiceImpl) SaveOfflineMessage(ctx context.Context, userID string, msg *Message) error {
    content, err := json.Marshal(msg)
    if err != nil {
        return err
    }
    
    offlineMsg := &OfflineMessage{
        UserID:         userID,
        MessageID:      msg.MessageID,
        ConversationID: msg.ConversationID,
        Content:        string(content),
        Pushed:         false,
        CreatedAt:      time.Now(),
        ExpireAt:       time.Now().Add(offlineMessageExpire),
    }
    
    // å­˜å…¥æ•°æ®åº“
    if err := s.db.Create(offlineMsg).Error; err != nil {
        return err
    }
    
    // åŒæ—¶å­˜å…¥Redisç”¨äºå¿«é€ŸæŸ¥è¯¢ï¼ˆå¸¦è¿‡æœŸæ—¶é—´ï¼‰
    redisKey := "offline:" + userID
    s.redis.ZAdd(ctx, redisKey, &redis.Z{
        Score:  float64(msg.Timestamp),
        Member: string(content),
    })
    s.redis.Expire(ctx, redisKey, offlineMessageExpire)
    
    // æ§åˆ¶Redisä¸­æ¶ˆæ¯æ•°é‡
    s.redis.ZRemRangeByRank(ctx, redisKey, 0, -maxOfflineMessages-1)
    
    return nil
}

// PullOfflineMessages æ‹‰å–ç¦»çº¿æ¶ˆæ¯
func (s *offlineServiceImpl) PullOfflineMessages(ctx context.Context, userID string, lastMsgID string, limit int) ([]*Message, error) {
    redisKey := "offline:" + userID
    
    var minScore string
    if lastMsgID != "" {
        // æ ¹æ®lastMsgIDæ‰¾åˆ°å¯¹åº”çš„æ—¶é—´æˆ³
        var offlineMsg OfflineMessage
        if err := s.db.Where("message_id = ?", lastMsgID).First(&offlineMsg).Error; err == nil {
            // ä»è¯¥æ¶ˆæ¯çš„ä¸‹ä¸€æ¡å¼€å§‹
            minScore = "(" + strconv.FormatInt(offlineMsg.CreatedAt.UnixMilli(), 10)
        } else {
            minScore = "-inf"
        }
    } else {
        minScore = "-inf"
    }
    
    // ä¼˜å…ˆä»Redisè·å–
    results, err := s.redis.ZRangeByScore(ctx, redisKey, &redis.ZRangeBy{
        Min:   minScore,
        Max:   "+inf",
        Count: int64(limit),
    }).Result()
    
    if err == nil && len(results) > 0 {
        messages := make([]*Message, 0, len(results))
        for _, content := range results {
            var msg Message
            if err := json.Unmarshal([]byte(content), &msg); err == nil {
                messages = append(messages, &msg)
            }
        }
        return messages, nil
    }
    
    // Redisæ²¡æœ‰æ•°æ®ï¼Œä»æ•°æ®åº“è·å–
    var offlineMsgs []OfflineMessage
    query := s.db.Where("user_id = ? AND expire_at > ?", userID, time.Now())
    if lastMsgID != "" {
        var lastMsg OfflineMessage
        if err := s.db.Where("message_id = ?", lastMsgID).First(&lastMsg).Error; err == nil {
            query = query.Where("created_at > ?", lastMsg.CreatedAt)
        }
    }
    
    if err := query.Order("created_at ASC").Limit(limit).Find(&offlineMsgs).Error; err != nil {
        return nil, err
    }
    
    messages := make([]*Message, 0, len(offlineMsgs))
    for _, om := range offlineMsgs {
        var msg Message
        if err := json.Unmarshal([]byte(om.Content), &msg); err == nil {
            messages = append(messages, &msg)
        }
    }
    
    return messages, nil
}

// DeleteOfflineMessages åˆ é™¤ç¦»çº¿æ¶ˆæ¯ï¼ˆç”¨æˆ·å·²æ”¶åˆ°åè°ƒç”¨ï¼‰
func (s *offlineServiceImpl) DeleteOfflineMessages(ctx context.Context, userID string, messageIDs []string) error {
    // ä»æ•°æ®åº“åˆ é™¤
    if err := s.db.Where("user_id = ? AND message_id IN ?", userID, messageIDs).
        Delete(&OfflineMessage{}).Error; err != nil {
        return err
    }
    
    // ä»Redisåˆ é™¤ï¼ˆéœ€è¦å…ˆæŸ¥å‡ºæ¶ˆæ¯å†…å®¹ï¼‰
    redisKey := "offline:" + userID
    for _, msgID := range messageIDs {
        var offlineMsg OfflineMessage
        if err := s.db.Unscoped().Where("message_id = ?", msgID).First(&offlineMsg).Error; err == nil {
            s.redis.ZRem(ctx, redisKey, offlineMsg.Content)
        }
    }
    
    return nil
}

// GetUnpushedMessages è·å–æœªæ¨é€çš„æ¶ˆæ¯
func (s *offlineServiceImpl) GetUnpushedMessages(ctx context.Context, limit int) ([]*OfflineMessage, error) {
    var messages []*OfflineMessage
    err := s.db.Where("pushed = ? AND expire_at > ?", false, time.Now()).
        Order("created_at ASC").
        Limit(limit).
        Find(&messages).Error
    return messages, err
}

// MarkAsPushed æ ‡è®°ä¸ºå·²æ¨é€
func (s *offlineServiceImpl) MarkAsPushed(ctx context.Context, messageIDs []string) error {
    now := time.Now()
    return s.db.Model(&OfflineMessage{}).
        Where("message_id IN ?", messageIDs).
        Updates(map[string]interface{}{
            "pushed":    true,
            "pushed_at": now,
        }).Error
}

// CleanExpiredMessages æ¸…ç†è¿‡æœŸæ¶ˆæ¯
func (s *offlineServiceImpl) CleanExpiredMessages(ctx context.Context) (int64, error) {
    result := s.db.Where("expire_at < ?", time.Now()).Delete(&OfflineMessage{})
    return result.RowsAffected, result.Error
}
```

### 3.2 æ¨é€æœåŠ¡ï¼ˆAPNs/FCMï¼‰

```go
// push_service.go

package service

import (
    "context"
    "log"
    "time"
    
    firebase "firebase.google.com/go/v4"
    "firebase.google.com/go/v4/messaging"
    "github.com/sideshow/apns2"
    "github.com/sideshow/apns2/certificate"
    "github.com/sideshow/apns2/payload"
)

// PushService æ¨é€æœåŠ¡æ¥å£
type PushService interface {
    // æ¨é€åˆ°iOSè®¾å¤‡
    PushToIOS(ctx context.Context, deviceToken string, notification *PushNotification) error
    
    // æ¨é€åˆ°Androidè®¾å¤‡
    PushToAndroid(ctx context.Context, deviceToken string, notification *PushNotification) error
    
    // æ‰¹é‡æ¨é€
    BatchPush(ctx context.Context, push *BatchPushRequest) error
    
    // å¯åŠ¨æ¨é€Worker
    StartPushWorker(ctx context.Context)
}

// PushNotification æ¨é€é€šçŸ¥å†…å®¹
type PushNotification struct {
    Title       string            `json:"title"`
    Body        string            `json:"body"`
    Badge       int               `json:"badge"`
    Sound       string            `json:"sound"`
    Data        map[string]string `json:"data"`
    Category    string            `json:"category"`
    ThreadID    string            `json:"thread_id"` // ä¼šè¯IDï¼Œç”¨äºæ¶ˆæ¯åˆ†ç»„
    MessageID   string            `json:"message_id"`
    CollapseKey string            `json:"collapse_key"` // æ¶ˆæ¯æŠ˜å 
}

// BatchPushRequest æ‰¹é‡æ¨é€è¯·æ±‚
type BatchPushRequest struct {
    IOSTokens     []string          `json:"ios_tokens"`
    AndroidTokens []string          `json:"android_tokens"`
    Notification  *PushNotification `json:"notification"`
}

// DeviceInfo è®¾å¤‡ä¿¡æ¯
type DeviceInfo struct {
    UserID      string `json:"user_id" gorm:"type:varchar(64);index"`
    DeviceToken string `json:"device_token" gorm:"type:varchar(256);uniqueIndex"`
    Platform    string `json:"platform" gorm:"type:varchar(16)"` // ios/android
    AppVersion  string `json:"app_version" gorm:"type:varchar(32)"`
    UpdatedAt   time.Time
}

type pushServiceImpl struct {
    apnsClient     *apns2.Client
    fcmClient      *messaging.Client
    offlineService OfflineService
    deviceRepo     DeviceRepository
    bundleID       string
}

func NewPushService(
    apnsCertPath string,
    apnsCertPassword string,
    bundleID string,
    firebaseApp *firebase.App,
    offlineService OfflineService,
    deviceRepo DeviceRepository,
) (PushService, error) {
    // åˆå§‹åŒ–APNså®¢æˆ·ç«¯
    cert, err := certificate.FromP12File(apnsCertPath, apnsCertPassword)
    if err != nil {
        return nil, err
    }
    apnsClient := apns2.NewClient(cert).Production()
    
    // åˆå§‹åŒ–FCMå®¢æˆ·ç«¯
    fcmClient, err := firebaseApp.Messaging(context.Background())
    if err != nil {
        return nil, err
    }
    
    return &pushServiceImpl{
        apnsClient:     apnsClient,
        fcmClient:      fcmClient,
        offlineService: offlineService,
        deviceRepo:     deviceRepo,
        bundleID:       bundleID,
    }, nil
}

// PushToIOS æ¨é€åˆ°iOS
func (s *pushServiceImpl) PushToIOS(ctx context.Context, deviceToken string, notification *PushNotification) error {
    p := payload.NewPayload().
        AlertTitle(notification.Title).
        AlertBody(notification.Body).
        Badge(notification.Badge).
        Sound(notification.Sound).
        ThreadID(notification.ThreadID).
        Category(notification.Category)
    
    // æ·»åŠ è‡ªå®šä¹‰æ•°æ®
    for k, v := range notification.Data {
        p.Custom(k, v)
    }
    
    apnsNotification := &apns2.Notification{
        DeviceToken: deviceToken,
        Topic:       s.bundleID,
        Payload:     p,
        CollapseID:  notification.CollapseKey,
    }
    
    resp, err := s.apnsClient.Push(apnsNotification)
    if err != nil {
        return err
    }
    
    if !resp.Sent() {
        log.Printf("APNs push failed: %s, reason: %s", deviceToken, resp.Reason)
        // å¦‚æœæ˜¯æ— æ•ˆtokenï¼Œåˆ é™¤è®¾å¤‡è®°å½•
        if resp.Reason == apns2.ReasonBadDeviceToken || resp.Reason == apns2.ReasonUnregistered {
            s.deviceRepo.DeleteByToken(ctx, deviceToken)
        }
    }
    
    return nil
}

// PushToAndroid æ¨é€åˆ°Android
func (s *pushServiceImpl) PushToAndroid(ctx context.Context, deviceToken string, notification *PushNotification) error {
    message := &messaging.Message{
        Token: deviceToken,
        Notification: &messaging.Notification{
            Title: notification.Title,
            Body:  notification.Body,
        },
        Android: &messaging.AndroidConfig{
            Priority: "high",
            Notification: &messaging.AndroidNotification{
                Sound:       notification.Sound,
                ClickAction: "OPEN_CHAT",
                Tag:         notification.CollapseKey,
            },
            CollapseKey: notification.CollapseKey,
        },
        Data: notification.Data,
    }
    
    _, err := s.fcmClient.Send(ctx, message)
    if err != nil {
        log.Printf("FCM push failed: %s, error: %v", deviceToken, err)
        // å¤„ç†æ— æ•ˆtoken
        if messaging.IsUnregistered(err) || messaging.IsInvalidArgument(err) {
            s.deviceRepo.DeleteByToken(ctx, deviceToken)
        }
    }
    
    return err
}

// BatchPush æ‰¹é‡æ¨é€
func (s *pushServiceImpl) BatchPush(ctx context.Context, req *BatchPushRequest) error {
    // iOSæ‰¹é‡æ¨é€
    for _, token := range req.IOSTokens {
        go s.PushToIOS(ctx, token, req.Notification)
    }
    
    // Androidæ‰¹é‡æ¨é€ï¼ˆFCMæ”¯æŒæ‰¹é‡ï¼‰
    if len(req.AndroidTokens) > 0 {
        messages := make([]*messaging.Message, 0, len(req.AndroidTokens))
        for _, token := range req.AndroidTokens {
            messages = append(messages, &messaging.Message{
                Token: token,
                Notification: &messaging.Notification{
                    Title: req.Notification.Title,
                    Body:  req.Notification.Body,
                },
                Data: req.Notification.Data,
            })
        }
        
        // FCMæ‰¹é‡å‘é€æœ€å¤š500æ¡
        for i := 0; i < len(messages); i += 500 {
            end := i + 500
            if end > len(messages) {
                end = len(messages)
            }
            s.fcmClient.SendEach(ctx, messages[i:end])
        }
    }
    
    return nil
}

// StartPushWorker å¯åŠ¨æ¨é€Worker
func (s *pushServiceImpl) StartPushWorker(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            s.processPendingPush(ctx)
        }
    }
}

// processPendingPush å¤„ç†å¾…æ¨é€çš„æ¶ˆæ¯
func (s *pushServiceImpl) processPendingPush(ctx context.Context) {
    // è·å–æœªæ¨é€çš„ç¦»çº¿æ¶ˆæ¯
    messages, err := s.offlineService.GetUnpushedMessages(ctx, 100)
    if err != nil || len(messages) == 0 {
        return
    }
    
    // æŒ‰ç”¨æˆ·åˆ†ç»„
    userMessages := make(map[string][]*OfflineMessage)
    for _, msg := range messages {
        userMessages[msg.UserID] = append(userMessages[msg.UserID], msg)
    }
    
    pushedIDs := make([]string, 0)
    
    for userID, msgs := range userMessages {
        // è·å–ç”¨æˆ·çš„è®¾å¤‡ä¿¡æ¯
        devices, err := s.deviceRepo.GetUserDevices(ctx, userID)
        if err != nil || len(devices) == 0 {
            // æ²¡æœ‰è®¾å¤‡ä¿¡æ¯ï¼Œä¹Ÿæ ‡è®°ä¸ºå·²å¤„ç†
            for _, msg := range msgs {
                pushedIDs = append(pushedIDs, msg.MessageID)
            }
            continue
        }
        
        // æ„é€ æ¨é€å†…å®¹ï¼ˆåˆå¹¶å¤šæ¡æ¶ˆæ¯ï¼‰
        notification := s.buildNotification(msgs)
        
        // æ¨é€åˆ°æ‰€æœ‰è®¾å¤‡
        for _, device := range devices {
            switch device.Platform {
            case "ios":
                go s.PushToIOS(ctx, device.DeviceToken, notification)
            case "android":
                go s.PushToAndroid(ctx, device.DeviceToken, notification)
            }
        }
        
        for _, msg := range msgs {
            pushedIDs = append(pushedIDs, msg.MessageID)
        }
    }
    
    // æ ‡è®°ä¸ºå·²æ¨é€
    if len(pushedIDs) > 0 {
        s.offlineService.MarkAsPushed(ctx, pushedIDs)
    }
}

// buildNotification æ„å»ºæ¨é€é€šçŸ¥
func (s *pushServiceImpl) buildNotification(msgs []*OfflineMessage) *PushNotification {
    if len(msgs) == 1 {
        // å•æ¡æ¶ˆæ¯
        var message Message
        json.Unmarshal([]byte(msgs[0].Content), &message)
        
        return &PushNotification{
            Title:       s.getNotificationTitle(&message),
            Body:        s.getNotificationBody(&message),
            Badge:       1,
            Sound:       "default",
            ThreadID:    message.ConversationID,
            MessageID:   message.MessageID,
            CollapseKey: message.ConversationID,
            Data: map[string]string{
                "conversation_id": message.ConversationID,
                "message_id":      message.MessageID,
            },
        }
    }
    
    // å¤šæ¡æ¶ˆæ¯ï¼Œåˆå¹¶æ˜¾ç¤º
    return &PushNotification{
        Title: "æ–°æ¶ˆæ¯",
        Body:  fmt.Sprintf("æ‚¨æœ‰ %d æ¡æ–°æ¶ˆæ¯", len(msgs)),
        Badge: len(msgs),
        Sound: "default",
        Data: map[string]string{
            "count": strconv.Itoa(len(msgs)),
        },
    }
}

func (s *pushServiceImpl) getNotificationTitle(msg *Message) string {
    // æ ¹æ®æ¶ˆæ¯ç±»å‹è¿”å›æ ‡é¢˜
    switch msg.Type {
    case MsgGroupChat:
        return "ç¾¤æ¶ˆæ¯"
    default:
        return "æ–°æ¶ˆæ¯"
    }
}

func (s *pushServiceImpl) getNotificationBody(msg *Message) string {
    // è§£ææ¶ˆæ¯å†…å®¹è¿”å›æ‘˜è¦
    if content, ok := msg.Content.(map[string]interface{}); ok {
        if text, ok := content["text"].(string); ok {
            if len(text) > 50 {
                return text[:50] + "..."
            }
            return text
        }
    }
    return "æ‚¨æ”¶åˆ°ä¸€æ¡æ–°æ¶ˆæ¯"
}
```

### 3.3 ç¦»çº¿æ¶ˆæ¯æ‹‰å–API

```go
// offline_handler.go

package handler

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
)

type OfflineHandler struct {
    offlineService OfflineService
}

func NewOfflineHandler(os OfflineService) *OfflineHandler {
    return &OfflineHandler{offlineService: os}
}

func (h *OfflineHandler) RegisterRoutes(r *gin.RouterGroup) {
    offline := r.Group("/offline")
    {
        offline.GET("/pull", h.PullMessages)
        offline.POST("/ack", h.AckMessages)
    }
    
    // è®¾å¤‡æ³¨å†Œ
    r.POST("/device/register", h.RegisterDevice)
}

// PullMessages æ‹‰å–ç¦»çº¿æ¶ˆæ¯
// GET /api/offline/pull?last_msg_id=xxx&limit=50
func (h *OfflineHandler) PullMessages(c *gin.Context) {
    userID := c.GetString("user_id")
    lastMsgID := c.Query("last_msg_id")
    limit := c.DefaultQuery("limit", "50")
    
    limitInt := 50
    if l, err := strconv.Atoi(limit); err == nil && l > 0 && l <= 100 {
        limitInt = l
    }
    
    messages, err := h.offlineService.PullOfflineMessages(
        c.Request.Context(),
        userID,
        lastMsgID,
        limitInt,
    )
    
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": gin.H{
            "messages": messages,
            "has_more": len(messages) == limitInt,
        },
    })
}

// AckMessages ç¡®è®¤æ”¶åˆ°ç¦»çº¿æ¶ˆæ¯
// POST /api/offline/ack
func (h *OfflineHandler) AckMessages(c *gin.Context) {
    userID := c.GetString("user_id")
    
    var req struct {
        MessageIDs []string `json:"message_ids" binding:"required"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    err := h.offlineService.DeleteOfflineMessages(c.Request.Context(), userID, req.MessageIDs)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success"})
}

// RegisterDevice æ³¨å†Œè®¾å¤‡ï¼ˆç”¨äºæ¨é€ï¼‰
// POST /api/device/register
func (h *OfflineHandler) RegisterDevice(c *gin.Context) {
    userID := c.GetString("user_id")
    
    var req struct {
        DeviceToken string `json:"device_token" binding:"required"`
        Platform    string `json:"platform" binding:"required,oneof=ios android"`
        AppVersion  string `json:"app_version"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // ä¿å­˜è®¾å¤‡ä¿¡æ¯
    device := &DeviceInfo{
        UserID:      userID,
        DeviceToken: req.DeviceToken,
        Platform:    req.Platform,
        AppVersion:  req.AppVersion,
        UpdatedAt:   time.Now(),
    }
    
    // Upsert
    err := h.deviceRepo.Upsert(c.Request.Context(), device)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success"})
}
```

---

## ä¸ƒã€æ¶ˆæ¯å¢å¼ºåŠŸèƒ½

### 4.1 æ¶ˆæ¯å·²è¯»å›æ‰§

```go
// read_receipt_service.go

package service

import (
    "context"
    "time"
    
    "github.com/go-redis/redis/v8"
)

// ReadReceiptService å·²è¯»å›æ‰§æœåŠ¡
type ReadReceiptService interface {
    // æ›´æ–°å·²è¯»ä½ç½®
    UpdateReadPosition(ctx context.Context, userID, conversationID string, lastReadSeq int64) error
    
    // è·å–ä¼šè¯çš„å·²è¯»çŠ¶æ€
    GetReadStatus(ctx context.Context, conversationID string, userIDs []string) (map[string]int64, error)
    
    // å‘é€å·²è¯»å›æ‰§é€šçŸ¥
    SendReadReceipt(ctx context.Context, userID, conversationID string, lastReadMsgID string, lastReadSeq int64) error
}

type readReceiptServiceImpl struct {
    redis         *redis.Client
    msgDispatcher MessageDispatcher
}

func NewReadReceiptService(redis *redis.Client, dispatcher MessageDispatcher) ReadReceiptService {
    return &readReceiptServiceImpl{
        redis:         redis,
        msgDispatcher: dispatcher,
    }
}

// UpdateReadPosition æ›´æ–°å·²è¯»ä½ç½®
func (s *readReceiptServiceImpl) UpdateReadPosition(ctx context.Context, userID, conversationID string, lastReadSeq int64) error {
    key := "read:" + conversationID
    return s.redis.HSet(ctx, key, userID, lastReadSeq).Err()
}

// GetReadStatus è·å–ä¼šè¯çš„å·²è¯»çŠ¶æ€
func (s *readReceiptServiceImpl) GetReadStatus(ctx context.Context, conversationID string, userIDs []string) (map[string]int64, error) {
    key := "read:" + conversationID
    result := make(map[string]int64)
    
    for _, userID := range userIDs {
        seq, err := s.redis.HGet(ctx, key, userID).Int64()
        if err == nil {
            result[userID] = seq
        }
    }
    
    return result, nil
}

// SendReadReceipt å‘é€å·²è¯»å›æ‰§é€šçŸ¥
func (s *readReceiptServiceImpl) SendReadReceipt(ctx context.Context, userID, conversationID string, lastReadMsgID string, lastReadSeq int64) error {
    // æ›´æ–°å·²è¯»ä½ç½®
    if err := s.UpdateReadPosition(ctx, userID, conversationID, lastReadSeq); err != nil {
        return err
    }
    
    // æ„é€ å·²è¯»å›æ‰§æ¶ˆæ¯
    content := &ReadReceiptContent{
        ConversationID:    conversationID,
        LastReadMessageID: lastReadMsgID,
        LastReadSeq:       lastReadSeq,
    }
    
    msg := &Message{
        MessageID:      uuid.New().String(),
        Type:           MsgReadReceipt,
        From:           userID,
        To:             conversationID,
        Content:        content,
        Timestamp:      time.Now().UnixMilli(),
        ConversationID: conversationID,
    }
    
    // å‘é€ç»™ä¼šè¯çš„å¦ä¸€æ–¹ï¼ˆå•èŠï¼‰æˆ–æ‰€æœ‰ç¾¤æˆå‘˜ï¼ˆç¾¤èŠï¼‰
    return s.msgDispatcher.DispatchToConversation(ctx, msg, conversationID, userID)
}
```

### 4.2 æ¶ˆæ¯æ’¤å›

```go
// revoke_service.go

package service

import (
    "context"
    "errors"
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

const (
    maxRevokeTime = 2 * time.Minute // æ’¤å›æ—¶é—´é™åˆ¶2åˆ†é’Ÿ
)

var (
    ErrRevokeTimeout    = errors.New("message revoke timeout")
    ErrNotMessageSender = errors.New("not the message sender")
    ErrMessageNotFound  = errors.New("message not found")
)

// RevokeService æ¶ˆæ¯æ’¤å›æœåŠ¡
type RevokeService interface {
    RevokeMessage(ctx context.Context, userID, messageID string) error
}

type revokeServiceImpl struct {
    db            *gorm.DB
    msgDispatcher MessageDispatcher
}

func NewRevokeService(db *gorm.DB, dispatcher MessageDispatcher) RevokeService {
    return &revokeServiceImpl{
        db:            db,
        msgDispatcher: dispatcher,
    }
}

// RevokeMessage æ’¤å›æ¶ˆæ¯
func (s *revokeServiceImpl) RevokeMessage(ctx context.Context, userID, messageID string) error {
    // æŸ¥æ‰¾åŸæ¶ˆæ¯
    var originalMsg MessageRecord
    if err := s.db.Where("message_id = ?", messageID).First(&originalMsg).Error; err != nil {
        return ErrMessageNotFound
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯æ¶ˆæ¯å‘é€è€…
    if originalMsg.FromUserID != userID {
        return ErrNotMessageSender
    }
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æ’¤å›æ—¶é—´
    if time.Since(originalMsg.CreatedAt) > maxRevokeTime {
        return ErrRevokeTimeout
    }
    
    // æ ‡è®°æ¶ˆæ¯ä¸ºå·²æ’¤å›
    if err := s.db.Model(&MessageRecord{}).Where("message_id = ?", messageID).
        Update("revoked", true).Error; err != nil {
        return err
    }
    
    // å‘é€æ’¤å›é€šçŸ¥
    content := &RevokeContent{
        TargetMessageID: messageID,
        ConversationID:  originalMsg.ConversationID,
    }
    
    msg := &Message{
        MessageID:      uuid.New().String(),
        Type:           MsgRevoke,
        From:           userID,
        To:             originalMsg.ToID,
        Content:        content,
        Timestamp:      time.Now().UnixMilli(),
        ConversationID: originalMsg.ConversationID,
    }
    
    // æ¨é€ç»™ä¼šè¯ä¸­çš„æ‰€æœ‰äºº
    return s.msgDispatcher.DispatchToConversation(ctx, msg, originalMsg.ConversationID, "")
}
```

### 4.3 æ¶ˆæ¯ACKç¡®è®¤æœºåˆ¶

```go
// ack_service.go

package service

import (
    "context"
    "sync"
    "time"
)

// MessageAckService æ¶ˆæ¯ç¡®è®¤æœåŠ¡
type MessageAckService interface {
    // ç­‰å¾…æ¶ˆæ¯ç¡®è®¤
    WaitAck(ctx context.Context, messageID string, timeout time.Duration) error
    
    // å¤„ç†ç¡®è®¤
    HandleAck(ctx context.Context, messageID string) error
    
    // é‡å‘æœªç¡®è®¤çš„æ¶ˆæ¯
    RetryUnacked(ctx context.Context) error
}

type messageAckServiceImpl struct {
    pendingAcks sync.Map // messageID -> chan struct{}
    retryQueue  chan *Message
}

func NewMessageAckService() MessageAckService {
    return &messageAckServiceImpl{
        retryQueue: make(chan *Message, 10000),
    }
}

// WaitAck ç­‰å¾…æ¶ˆæ¯ç¡®è®¤
func (s *messageAckServiceImpl) WaitAck(ctx context.Context, messageID string, timeout time.Duration) error {
    ackChan := make(chan struct{}, 1)
    s.pendingAcks.Store(messageID, ackChan)
    defer s.pendingAcks.Delete(messageID)
    
    select {
    case <-ackChan:
        return nil
    case <-time.After(timeout):
        return errors.New("ack timeout")
    case <-ctx.Done():
        return ctx.Err()
    }
}

// HandleAck å¤„ç†ç¡®è®¤
func (s *messageAckServiceImpl) HandleAck(ctx context.Context, messageID string) error {
    if ch, ok := s.pendingAcks.Load(messageID); ok {
        close(ch.(chan struct{}))
        s.pendingAcks.Delete(messageID)
    }
    return nil
}
```

---

## å…«ã€æ–‡ä»¶æ¶ˆæ¯æ”¯æŒ

### 7.1 æ–‡ä»¶æ¶ˆæ¯ç±»å‹å®šä¹‰

```go
// file_message.go

package model

// FileType æ–‡ä»¶ç±»å‹
type FileType int

const (
    FileTypeImage    FileType = 1  // å›¾ç‰‡
    FileTypeVideo    FileType = 2  // è§†é¢‘
    FileTypeAudio    FileType = 3  // éŸ³é¢‘
    FileTypeDocument FileType = 4  // æ–‡æ¡£ (PDF/Word/Excel/PPT)
    FileTypeArchive  FileType = 5  // å‹ç¼©åŒ…
    FileTypeOther    FileType = 6  // å…¶ä»–
)

// FileMessage æ–‡ä»¶æ¶ˆæ¯å†…å®¹
type FileMessage struct {
    FileID       string   `json:"file_id"`        // æ–‡ä»¶å”¯ä¸€ID
    FileType     FileType `json:"file_type"`      // æ–‡ä»¶ç±»å‹
    FileName     string   `json:"file_name"`      // åŸå§‹æ–‡ä»¶å
    FileSize     int64    `json:"file_size"`      // æ–‡ä»¶å¤§å°(å­—èŠ‚)
    FileExt      string   `json:"file_ext"`       // æ–‡ä»¶æ‰©å±•å
    MimeType     string   `json:"mime_type"`      // MIMEç±»å‹
    URL          string   `json:"url"`            // æ–‡ä»¶è®¿é—®URL
    ThumbnailURL string   `json:"thumbnail_url"`  // ç¼©ç•¥å›¾URL(å›¾ç‰‡/è§†é¢‘)
    Width        int      `json:"width,omitempty"`  // å›¾ç‰‡/è§†é¢‘å®½åº¦
    Height       int      `json:"height,omitempty"` // å›¾ç‰‡/è§†é¢‘é«˜åº¦
    Duration     int      `json:"duration,omitempty"` // éŸ³é¢‘/è§†é¢‘æ—¶é•¿(ç§’)
    MD5          string   `json:"md5"`            // æ–‡ä»¶MD5(ç”¨äºå»é‡å’Œæ ¡éªŒ)
    UploadStatus int      `json:"upload_status"`  // ä¸Šä¼ çŠ¶æ€: 0-ä¸Šä¼ ä¸­ 1-å·²å®Œæˆ 2-å¤±è´¥
}

// ImageMessage å›¾ç‰‡æ¶ˆæ¯(FileMessageçš„ç®€åŒ–ç‰ˆ)
type ImageMessage struct {
    FileID       string `json:"file_id"`
    URL          string `json:"url"`
    ThumbnailURL string `json:"thumbnail_url"`
    Width        int    `json:"width"`
    Height       int    `json:"height"`
    FileSize     int64  `json:"file_size"`
}

// DocumentMessage æ–‡æ¡£æ¶ˆæ¯
type DocumentMessage struct {
    FileID   string `json:"file_id"`
    FileName string `json:"file_name"`
    FileSize int64  `json:"file_size"`
    FileExt  string `json:"file_ext"`
    URL      string `json:"url"`
    Preview  string `json:"preview,omitempty"` // æ–‡æ¡£é¢„è§ˆURL
    Pages    int    `json:"pages,omitempty"`   // æ–‡æ¡£é¡µæ•°
}
```

### 7.2 æ‰©å±•æ¶ˆæ¯ç±»å‹æšä¸¾

```go
// åœ¨ message_types.go ä¸­æ·»åŠ 

const (
    // åŸºç¡€æ¶ˆæ¯ç±»å‹ (1-9)
    MsgText   MessageType = 1  // æ–‡æœ¬æ¶ˆæ¯
    MsgImage  MessageType = 2  // å›¾ç‰‡æ¶ˆæ¯
    MsgVoice  MessageType = 3  // è¯­éŸ³æ¶ˆæ¯
    MsgVideo  MessageType = 4  // è§†é¢‘æ¶ˆæ¯
    MsgFile   MessageType = 5  // æ–‡ä»¶æ¶ˆæ¯
    MsgLocation MessageType = 6 // ä½ç½®æ¶ˆæ¯
    MsgCard   MessageType = 7  // åç‰‡æ¶ˆæ¯
    MsgCustom MessageType = 8  // è‡ªå®šä¹‰æ¶ˆæ¯
    
    // ... å…¶ä»–æ¶ˆæ¯ç±»å‹ä¿æŒä¸å˜
)
```

### 7.3 æ–‡ä»¶å­˜å‚¨æœåŠ¡

```go
// file_storage.go

package service

import (
    "context"
    "crypto/md5"
    "encoding/hex"
    "fmt"
    "io"
    "mime/multipart"
    "path/filepath"
    "strings"
    "time"

    "github.com/minio/minio-go/v7"
    "github.com/minio/minio-go/v7/pkg/credentials"
)

// StorageConfig å­˜å‚¨é…ç½®
type StorageConfig struct {
    Provider    string // minio/oss/s3/local
    Endpoint    string
    AccessKey   string
    SecretKey   string
    Bucket      string
    Region      string
    UseSSL      bool
    CDNDomain   string // CDNåŠ é€ŸåŸŸå
}

// FileStorageService æ–‡ä»¶å­˜å‚¨æœåŠ¡æ¥å£
type FileStorageService interface {
    // ä¸Šä¼ æ–‡ä»¶
    Upload(ctx context.Context, file *UploadFileRequest) (*FileInfo, error)
    
    // åˆ†ç‰‡ä¸Šä¼ åˆå§‹åŒ–
    InitMultipartUpload(ctx context.Context, fileName string, fileSize int64) (*MultipartUploadInfo, error)
    
    // ä¸Šä¼ åˆ†ç‰‡
    UploadPart(ctx context.Context, uploadID string, partNumber int, data io.Reader, size int64) (*PartInfo, error)
    
    // å®Œæˆåˆ†ç‰‡ä¸Šä¼ 
    CompleteMultipartUpload(ctx context.Context, uploadID string, parts []PartInfo) (*FileInfo, error)
    
    // è·å–æ–‡ä»¶è®¿é—®URL
    GetFileURL(ctx context.Context, fileID string, expiry time.Duration) (string, error)
    
    // åˆ é™¤æ–‡ä»¶
    Delete(ctx context.Context, fileID string) error
    
    // ç”Ÿæˆç¼©ç•¥å›¾
    GenerateThumbnail(ctx context.Context, fileID string, width, height int) (string, error)
}

// UploadFileRequest ä¸Šä¼ æ–‡ä»¶è¯·æ±‚
type UploadFileRequest struct {
    File        multipart.File
    Header      *multipart.FileHeader
    UserID      string
    ContentType string
}

// FileInfo æ–‡ä»¶ä¿¡æ¯
type FileInfo struct {
    FileID       string    `json:"file_id"`
    FileName     string    `json:"file_name"`
    FileSize     int64     `json:"file_size"`
    FileExt      string    `json:"file_ext"`
    MimeType     string    `json:"mime_type"`
    URL          string    `json:"url"`
    ThumbnailURL string    `json:"thumbnail_url,omitempty"`
    MD5          string    `json:"md5"`
    UploadedAt   time.Time `json:"uploaded_at"`
}

// MultipartUploadInfo åˆ†ç‰‡ä¸Šä¼ ä¿¡æ¯
type MultipartUploadInfo struct {
    UploadID   string `json:"upload_id"`
    FileID     string `json:"file_id"`
    ChunkSize  int64  `json:"chunk_size"`
    TotalParts int    `json:"total_parts"`
}

// PartInfo åˆ†ç‰‡ä¿¡æ¯
type PartInfo struct {
    PartNumber int    `json:"part_number"`
    ETag       string `json:"etag"`
    Size       int64  `json:"size"`
}

// MinioStorageService MinIOå®ç°
type minioStorageService struct {
    client    *minio.Client
    bucket    string
    cdnDomain string
}

func NewMinioStorageService(config *StorageConfig) (FileStorageService, error) {
    client, err := minio.New(config.Endpoint, &minio.Options{
        Creds:  credentials.NewStaticV4(config.AccessKey, config.SecretKey, ""),
        Secure: config.UseSSL,
    })
    if err != nil {
        return nil, err
    }
    
    // ç¡®ä¿bucketå­˜åœ¨
    ctx := context.Background()
    exists, err := client.BucketExists(ctx, config.Bucket)
    if err != nil {
        return nil, err
    }
    if !exists {
        err = client.MakeBucket(ctx, config.Bucket, minio.MakeBucketOptions{Region: config.Region})
        if err != nil {
            return nil, err
        }
    }
    
    return &minioStorageService{
        client:    client,
        bucket:    config.Bucket,
        cdnDomain: config.CDNDomain,
    }, nil
}

// Upload ä¸Šä¼ æ–‡ä»¶
func (s *minioStorageService) Upload(ctx context.Context, req *UploadFileRequest) (*FileInfo, error) {
    // è®¡ç®—æ–‡ä»¶MD5
    hash := md5.New()
    tempFile, _ := io.ReadAll(req.File)
    hash.Write(tempFile)
    md5sum := hex.EncodeToString(hash.Sum(nil))
    
    // é‡ç½®æ–‡ä»¶è¯»å–ä½ç½®
    req.File.Seek(0, 0)
    
    // ç”Ÿæˆæ–‡ä»¶IDå’Œè·¯å¾„
    ext := strings.ToLower(filepath.Ext(req.Header.Filename))
    fileID := fmt.Sprintf("%s_%d%s", md5sum[:16], time.Now().UnixNano(), ext)
    objectPath := s.generateObjectPath(req.UserID, fileID)
    
    // ä¸Šä¼ åˆ°MinIO
    contentType := req.ContentType
    if contentType == "" {
        contentType = req.Header.Header.Get("Content-Type")
    }
    
    _, err := s.client.PutObject(ctx, s.bucket, objectPath, req.File, req.Header.Size, minio.PutObjectOptions{
        ContentType: contentType,
    })
    if err != nil {
        return nil, err
    }
    
    // æ„å»ºè®¿é—®URL
    url := s.buildFileURL(objectPath)
    
    // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œç”Ÿæˆç¼©ç•¥å›¾
    var thumbnailURL string
    if isImage(ext) {
        thumbnailURL, _ = s.GenerateThumbnail(ctx, fileID, 200, 200)
    }
    
    return &FileInfo{
        FileID:       fileID,
        FileName:     req.Header.Filename,
        FileSize:     req.Header.Size,
        FileExt:      ext,
        MimeType:     contentType,
        URL:          url,
        ThumbnailURL: thumbnailURL,
        MD5:          md5sum,
        UploadedAt:   time.Now(),
    }, nil
}

// InitMultipartUpload åˆå§‹åŒ–åˆ†ç‰‡ä¸Šä¼ 
func (s *minioStorageService) InitMultipartUpload(ctx context.Context, fileName string, fileSize int64) (*MultipartUploadInfo, error) {
    ext := strings.ToLower(filepath.Ext(fileName))
    fileID := fmt.Sprintf("%d_%s%s", time.Now().UnixNano(), generateRandomString(8), ext)
    objectPath := s.generateObjectPath("uploads", fileID)
    
    // MinIOåˆ†ç‰‡ä¸Šä¼ 
    uploadID, err := s.client.NewMultipartUpload(ctx, s.bucket, objectPath, minio.PutObjectOptions{})
    if err != nil {
        return nil, err
    }
    
    // è®¡ç®—åˆ†ç‰‡æ•°é‡ (æ¯ç‰‡5MB)
    chunkSize := int64(5 * 1024 * 1024) // 5MB
    totalParts := int((fileSize + chunkSize - 1) / chunkSize)
    
    return &MultipartUploadInfo{
        UploadID:   uploadID,
        FileID:     fileID,
        ChunkSize:  chunkSize,
        TotalParts: totalParts,
    }, nil
}

// UploadPart ä¸Šä¼ åˆ†ç‰‡
func (s *minioStorageService) UploadPart(ctx context.Context, uploadID string, partNumber int, data io.Reader, size int64) (*PartInfo, error) {
    // è¿™é‡Œéœ€è¦ä»uploadIDåæŸ¥objectPathï¼Œå®é™…é¡¹ç›®ä¸­åº”è¯¥å­˜å‚¨åœ¨Redisæˆ–æ•°æ®åº“ä¸­
    objectPath := "" // ä»ç¼“å­˜è·å–
    
    part, err := s.client.PutObjectPart(ctx, s.bucket, objectPath, uploadID, partNumber, data, size, minio.PutObjectPartOptions{})
    if err != nil {
        return nil, err
    }
    
    return &PartInfo{
        PartNumber: partNumber,
        ETag:       part.ETag,
        Size:       part.Size,
    }, nil
}

// GetFileURL è·å–æ–‡ä»¶è®¿é—®URL
func (s *minioStorageService) GetFileURL(ctx context.Context, fileID string, expiry time.Duration) (string, error) {
    objectPath := s.findObjectPath(fileID)
    
    presignedURL, err := s.client.PresignedGetObject(ctx, s.bucket, objectPath, expiry, nil)
    if err != nil {
        return "", err
    }
    
    return presignedURL.String(), nil
}

// GenerateThumbnail ç”Ÿæˆç¼©ç•¥å›¾
func (s *minioStorageService) GenerateThumbnail(ctx context.Context, fileID string, width, height int) (string, error) {
    // å®é™…é¡¹ç›®ä¸­åº”è¯¥ä½¿ç”¨å›¾ç‰‡å¤„ç†åº“(å¦‚imaging)ç”Ÿæˆç¼©ç•¥å›¾
    // æˆ–è€…ä½¿ç”¨äº‘æœåŠ¡çš„å›¾ç‰‡å¤„ç†åŠŸèƒ½(å¦‚é˜¿é‡Œäº‘OSSçš„å›¾ç‰‡å¤„ç†)
    
    // è¿”å›å¸¦ç¼©ç•¥å›¾å‚æ•°çš„URL (ä»¥OSSä¸ºä¾‹)
    // return fmt.Sprintf("%s?x-oss-process=image/resize,w_%d,h_%d", originalURL, width, height), nil
    
    thumbnailID := fmt.Sprintf("thumb_%dx%d_%s", width, height, fileID)
    return s.buildFileURL(thumbnailID), nil
}

// è¾…åŠ©å‡½æ•°
func (s *minioStorageService) generateObjectPath(prefix, fileID string) string {
    now := time.Now()
    return fmt.Sprintf("%s/%d/%02d/%02d/%s", prefix, now.Year(), now.Month(), now.Day(), fileID)
}

func (s *minioStorageService) buildFileURL(objectPath string) string {
    if s.cdnDomain != "" {
        return fmt.Sprintf("https://%s/%s", s.cdnDomain, objectPath)
    }
    return fmt.Sprintf("https://%s/%s/%s", s.client.EndpointURL().Host, s.bucket, objectPath)
}

func (s *minioStorageService) findObjectPath(fileID string) string {
    // å®é™…é¡¹ç›®ä¸­åº”è¯¥ä»æ•°æ®åº“æˆ–ç¼“å­˜ä¸­æŸ¥æ‰¾
    return ""
}

func isImage(ext string) bool {
    imageExts := map[string]bool{
        ".jpg": true, ".jpeg": true, ".png": true, ".gif": true, 
        ".webp": true, ".bmp": true, ".svg": true,
    }
    return imageExts[ext]
}

func generateRandomString(n int) string {
    // ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
    return fmt.Sprintf("%d", time.Now().UnixNano())[:n]
}
```

### 7.4 æ–‡ä»¶ä¸Šä¼ API

```go
// file_handler.go

package handler

import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
)

// æ–‡ä»¶å¤§å°é™åˆ¶
const (
    MaxImageSize    = 10 * 1024 * 1024   // 10MB
    MaxVideoSize    = 100 * 1024 * 1024  // 100MB
    MaxFileSize     = 50 * 1024 * 1024   // 50MB
    MaxAudioSize    = 20 * 1024 * 1024   // 20MB
)

// å…è®¸çš„æ–‡ä»¶ç±»å‹
var allowedFileTypes = map[string][]string{
    "image": {".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp"},
    "video": {".mp4", ".mov", ".avi", ".mkv", ".webm"},
    "audio": {".mp3", ".wav", ".aac", ".ogg", ".m4a"},
    "document": {".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".txt", ".csv"},
    "archive": {".zip", ".rar", ".7z", ".tar", ".gz"},
}

type FileHandler struct {
    storageService FileStorageService
    messageService MessageService
}

func NewFileHandler(storage FileStorageService, msgSvc MessageService) *FileHandler {
    return &FileHandler{
        storageService: storage,
        messageService: msgSvc,
    }
}

func (h *FileHandler) RegisterRoutes(r *gin.RouterGroup) {
    file := r.Group("/file")
    {
        file.POST("/upload", h.Upload)
        file.POST("/upload/init", h.InitMultipartUpload)
        file.POST("/upload/part", h.UploadPart)
        file.POST("/upload/complete", h.CompleteMultipartUpload)
        file.GET("/download/:file_id", h.Download)
        file.GET("/preview/:file_id", h.Preview)
    }
}

// Upload æ™®é€šæ–‡ä»¶ä¸Šä¼ 
// POST /api/file/upload
func (h *FileHandler) Upload(c *gin.Context) {
    userID := c.GetString("user_id")
    
    file, header, err := c.Request.FormFile("file")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "file required"})
        return
    }
    defer file.Close()
    
    // è·å–æ–‡ä»¶ç±»å‹
    fileType := c.PostForm("type") // image/video/audio/document/file
    
    // éªŒè¯æ–‡ä»¶å¤§å°
    maxSize := h.getMaxSize(fileType)
    if header.Size > maxSize {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": fmt.Sprintf("file too large, max size: %d MB", maxSize/1024/1024),
        })
        return
    }
    
    // éªŒè¯æ–‡ä»¶ç±»å‹
    if !h.isAllowedFileType(header.Filename, fileType) {
        c.JSON(http.StatusBadRequest, gin.H{"error": "file type not allowed"})
        return
    }
    
    // ä¸Šä¼ æ–‡ä»¶
    fileInfo, err := h.storageService.Upload(c.Request.Context(), &UploadFileRequest{
        File:   file,
        Header: header,
        UserID: userID,
    })
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": fileInfo,
    })
}

// InitMultipartUpload åˆå§‹åŒ–åˆ†ç‰‡ä¸Šä¼ 
// POST /api/file/upload/init
func (h *FileHandler) InitMultipartUpload(c *gin.Context) {
    var req struct {
        FileName string `json:"file_name" binding:"required"`
        FileSize int64  `json:"file_size" binding:"required,gt=0"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // éªŒè¯æ–‡ä»¶å¤§å°
    if req.FileSize > MaxVideoSize {
        c.JSON(http.StatusBadRequest, gin.H{"error": "file too large"})
        return
    }
    
    uploadInfo, err := h.storageService.InitMultipartUpload(c.Request.Context(), req.FileName, req.FileSize)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": uploadInfo,
    })
}

// UploadPart ä¸Šä¼ åˆ†ç‰‡
// POST /api/file/upload/part
func (h *FileHandler) UploadPart(c *gin.Context) {
    uploadID := c.PostForm("upload_id")
    partNumber, _ := strconv.Atoi(c.PostForm("part_number"))
    
    file, header, err := c.Request.FormFile("file")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "file required"})
        return
    }
    defer file.Close()
    
    partInfo, err := h.storageService.UploadPart(c.Request.Context(), uploadID, partNumber, file, header.Size)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": partInfo,
    })
}

// CompleteMultipartUpload å®Œæˆåˆ†ç‰‡ä¸Šä¼ 
// POST /api/file/upload/complete
func (h *FileHandler) CompleteMultipartUpload(c *gin.Context) {
    var req struct {
        UploadID string     `json:"upload_id" binding:"required"`
        Parts    []PartInfo `json:"parts" binding:"required"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    fileInfo, err := h.storageService.CompleteMultipartUpload(c.Request.Context(), req.UploadID, req.Parts)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 0,
        "data": fileInfo,
    })
}

// Download æ–‡ä»¶ä¸‹è½½
// GET /api/file/download/:file_id
func (h *FileHandler) Download(c *gin.Context) {
    fileID := c.Param("file_id")
    
    // è·å–å¸¦ç­¾åçš„ä¸‹è½½URL
    url, err := h.storageService.GetFileURL(c.Request.Context(), fileID, 30*time.Minute)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "file not found"})
        return
    }
    
    c.Redirect(http.StatusTemporaryRedirect, url)
}

// Preview æ–‡ä»¶é¢„è§ˆ (å›¾ç‰‡/æ–‡æ¡£)
// GET /api/file/preview/:file_id
func (h *FileHandler) Preview(c *gin.Context) {
    fileID := c.Param("file_id")
    width, _ := strconv.Atoi(c.DefaultQuery("w", "0"))
    height, _ := strconv.Atoi(c.DefaultQuery("h", "0"))
    
    var url string
    var err error
    
    if width > 0 && height > 0 {
        // ç”Ÿæˆç¼©ç•¥å›¾URL
        url, err = h.storageService.GenerateThumbnail(c.Request.Context(), fileID, width, height)
    } else {
        url, err = h.storageService.GetFileURL(c.Request.Context(), fileID, 30*time.Minute)
    }
    
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "file not found"})
        return
    }
    
    c.Redirect(http.StatusTemporaryRedirect, url)
}

func (h *FileHandler) getMaxSize(fileType string) int64 {
    switch fileType {
    case "image":
        return MaxImageSize
    case "video":
        return MaxVideoSize
    case "audio":
        return MaxAudioSize
    default:
        return MaxFileSize
    }
}

func (h *FileHandler) isAllowedFileType(filename, fileType string) bool {
    ext := strings.ToLower(filepath.Ext(filename))
    
    if fileType == "" || fileType == "file" {
        // æ£€æŸ¥æ‰€æœ‰å…è®¸çš„ç±»å‹
        for _, exts := range allowedFileTypes {
            for _, e := range exts {
                if e == ext {
                    return true
                }
            }
        }
        return false
    }
    
    allowedExts, ok := allowedFileTypes[fileType]
    if !ok {
        return false
    }
    
    for _, e := range allowedExts {
        if e == ext {
            return true
        }
    }
    return false
}
```

### 7.5 å‘é€æ–‡ä»¶æ¶ˆæ¯

```go
// å‘é€å›¾ç‰‡æ¶ˆæ¯ç¤ºä¾‹
func (s *messageServiceImpl) SendImageMessage(ctx context.Context, req *SendImageMessageRequest) (*Message, error) {
    // 1. å…ˆä¸Šä¼ å›¾ç‰‡
    fileInfo, err := s.storageService.Upload(ctx, &UploadFileRequest{
        File:   req.File,
        Header: req.Header,
        UserID: req.From,
    })
    if err != nil {
        return nil, err
    }
    
    // 2. æ„é€ å›¾ç‰‡æ¶ˆæ¯
    imageContent := &ImageMessage{
        FileID:       fileInfo.FileID,
        URL:          fileInfo.URL,
        ThumbnailURL: fileInfo.ThumbnailURL,
        Width:        req.Width,
        Height:       req.Height,
        FileSize:     fileInfo.FileSize,
    }
    
    // 3. å‘é€æ¶ˆæ¯
    msg := &Message{
        MessageID:      uuid.New().String(),
        Type:           MsgImage,
        From:           req.From,
        To:             req.To,
        Content:        imageContent,
        Timestamp:      time.Now().UnixMilli(),
        ConversationID: req.ConversationID,
    }
    
    return s.sendMessage(ctx, msg)
}

// å‘é€æ–‡æ¡£æ¶ˆæ¯ç¤ºä¾‹
func (s *messageServiceImpl) SendDocumentMessage(ctx context.Context, req *SendDocumentMessageRequest) (*Message, error) {
    // 1. å…ˆä¸Šä¼ æ–‡æ¡£
    fileInfo, err := s.storageService.Upload(ctx, &UploadFileRequest{
        File:   req.File,
        Header: req.Header,
        UserID: req.From,
    })
    if err != nil {
        return nil, err
    }
    
    // 2. æ„é€ æ–‡æ¡£æ¶ˆæ¯
    docContent := &DocumentMessage{
        FileID:   fileInfo.FileID,
        FileName: fileInfo.FileName,
        FileSize: fileInfo.FileSize,
        FileExt:  fileInfo.FileExt,
        URL:      fileInfo.URL,
    }
    
    // 3. å‘é€æ¶ˆæ¯
    msg := &Message{
        MessageID:      uuid.New().String(),
        Type:           MsgFile,
        From:           req.From,
        To:             req.To,
        Content:        docContent,
        Timestamp:      time.Now().UnixMilli(),
        ConversationID: req.ConversationID,
    }
    
    return s.sendMessage(ctx, msg)
}
```

### 7.6 å®¢æˆ·ç«¯å‘é€æ–‡ä»¶æ¶ˆæ¯ç¤ºä¾‹

```javascript
// Webç«¯å‘é€å›¾ç‰‡
async function sendImageMessage(conversationId, file) {
    // 1. ä¸Šä¼ å›¾ç‰‡
    const formData = new FormData();
    formData.append('file', file);
    formData.append('type', 'image');
    
    const uploadRes = await fetch('/api/file/upload', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}` },
        body: formData
    });
    const { data: fileInfo } = await uploadRes.json();
    
    // 2. å‘é€å›¾ç‰‡æ¶ˆæ¯
    const message = {
        type: 2, // MsgImage
        to: conversationId,
        content: {
            file_id: fileInfo.file_id,
            url: fileInfo.url,
            thumbnail_url: fileInfo.thumbnail_url,
            width: fileInfo.width || 0,
            height: fileInfo.height || 0,
            file_size: fileInfo.file_size
        }
    };
    
    ws.send(JSON.stringify(message));
}

// Webç«¯å‘é€æ–‡æ¡£
async function sendDocumentMessage(conversationId, file) {
    // 1. ä¸Šä¼ æ–‡æ¡£
    const formData = new FormData();
    formData.append('file', file);
    formData.append('type', 'document');
    
    const uploadRes = await fetch('/api/file/upload', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}` },
        body: formData
    });
    const { data: fileInfo } = await uploadRes.json();
    
    // 2. å‘é€æ–‡æ¡£æ¶ˆæ¯
    const message = {
        type: 5, // MsgFile
        to: conversationId,
        content: {
            file_id: fileInfo.file_id,
            file_name: fileInfo.file_name,
            file_size: fileInfo.file_size,
            file_ext: fileInfo.file_ext,
            url: fileInfo.url
        }
    };
    
    ws.send(JSON.stringify(message));
}

// å¤§æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼ 
async function uploadLargeFile(file, onProgress) {
    // 1. åˆå§‹åŒ–åˆ†ç‰‡ä¸Šä¼ 
    const initRes = await fetch('/api/file/upload/init', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            file_name: file.name,
            file_size: file.size
        })
    });
    const { data: uploadInfo } = await initRes.json();
    
    const { upload_id, chunk_size, total_parts } = uploadInfo;
    const parts = [];
    
    // 2. åˆ†ç‰‡ä¸Šä¼ 
    for (let i = 0; i < total_parts; i++) {
        const start = i * chunk_size;
        const end = Math.min(start + chunk_size, file.size);
        const chunk = file.slice(start, end);
        
        const formData = new FormData();
        formData.append('upload_id', upload_id);
        formData.append('part_number', i + 1);
        formData.append('file', chunk);
        
        const partRes = await fetch('/api/file/upload/part', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` },
            body: formData
        });
        const { data: partInfo } = await partRes.json();
        parts.push(partInfo);
        
        // æ›´æ–°è¿›åº¦
        onProgress?.((i + 1) / total_parts * 100);
    }
    
    // 3. å®Œæˆä¸Šä¼ 
    const completeRes = await fetch('/api/file/upload/complete', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            upload_id: upload_id,
            parts: parts
        })
    });
    
    return await completeRes.json();
}
```

```swift
// iOSç«¯å‘é€å›¾ç‰‡
func sendImageMessage(to conversationId: String, image: UIImage) async throws {
    // 1. å‹ç¼©å›¾ç‰‡
    guard let imageData = image.jpegData(compressionQuality: 0.8) else {
        throw IMError.invalidImage
    }
    
    // 2. ä¸Šä¼ å›¾ç‰‡
    let fileInfo = try await uploadFile(data: imageData, type: "image", fileName: "image.jpg")
    
    // 3. å‘é€å›¾ç‰‡æ¶ˆæ¯
    let content = ImageMessage(
        fileId: fileInfo.fileId,
        url: fileInfo.url,
        thumbnailUrl: fileInfo.thumbnailUrl,
        width: Int(image.size.width),
        height: Int(image.size.height),
        fileSize: Int64(imageData.count)
    )
    
    let message = Message(
        type: .image,
        to: conversationId,
        content: content
    )
    
    try await sendMessage(message)
}

// iOSç«¯å‘é€æ–‡æ¡£
func sendDocumentMessage(to conversationId: String, fileURL: URL) async throws {
    // 1. è¯»å–æ–‡ä»¶æ•°æ®
    let fileData = try Data(contentsOf: fileURL)
    let fileName = fileURL.lastPathComponent
    
    // 2. ä¸Šä¼ æ–‡æ¡£
    let fileInfo = try await uploadFile(data: fileData, type: "document", fileName: fileName)
    
    // 3. å‘é€æ–‡æ¡£æ¶ˆæ¯
    let content = DocumentMessage(
        fileId: fileInfo.fileId,
        fileName: fileInfo.fileName,
        fileSize: fileInfo.fileSize,
        fileExt: fileInfo.fileExt,
        url: fileInfo.url
    )
    
    let message = Message(
        type: .file,
        to: conversationId,
        content: content
    )
    
    try await sendMessage(message)
}
```

### 7.7 æ–‡ä»¶å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| **æœ¬åœ°å­˜å‚¨** | ç®€å•ã€æ— å¤–éƒ¨ä¾èµ– | ä¸æ”¯æŒåˆ†å¸ƒå¼ã€æ‰©å±•æ€§å·® | å¼€å‘æµ‹è¯•ã€å°å‹é¡¹ç›® |
| **MinIO** | å…¼å®¹S3 APIã€å¼€æºå…è´¹ã€å¯è‡ªå»º | éœ€è¦è‡ªå·±è¿ç»´ | ç§æœ‰åŒ–éƒ¨ç½²ã€ä¸­å‹é¡¹ç›® |
| **é˜¿é‡Œäº‘OSS** | ç¨³å®šå¯é ã€CDNé›†æˆã€å›¾ç‰‡å¤„ç† | æ”¶è´¹ | ç”Ÿäº§ç¯å¢ƒ |
| **è…¾è®¯äº‘COS** | åŒä¸Š | æ”¶è´¹ | ç”Ÿäº§ç¯å¢ƒ |
| **AWS S3** | å…¨çƒèŠ‚ç‚¹ã€ç”Ÿæ€å®Œå–„ | æ”¶è´¹è¾ƒè´µ | å›½é™…åŒ–é¡¹ç›® |

### 7.8 æ–‡ä»¶å®‰å…¨è®¾è®¡

```go
// æ–‡ä»¶è®¿é—®æ§åˆ¶
type FileAccessControl struct {
    // ç§æœ‰æ–‡ä»¶ç­¾åURL
    SignedURLExpiry time.Duration
    
    // é˜²ç›—é“¾é…ç½®
    RefererWhitelist []string
    
    // æ–‡ä»¶æ‰«æ(ç—…æ¯’/æ•æ„Ÿå†…å®¹)
    EnableVirusScan bool
    EnableContentScan bool
}

// ç”Ÿæˆå¸¦ç­¾åçš„ç§æœ‰æ–‡ä»¶URL
func (s *minioStorageService) GetPrivateFileURL(ctx context.Context, fileID string, userID string) (string, error) {
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®è¯¥æ–‡ä»¶
    hasAccess, err := s.checkFileAccess(ctx, fileID, userID)
    if err != nil || !hasAccess {
        return "", errors.New("access denied")
    }
    
    // ç”Ÿæˆå¸¦ç­¾åçš„URLï¼Œæœ‰æ•ˆæœŸ30åˆ†é’Ÿ
    return s.GetFileURL(ctx, fileID, 30*time.Minute)
}

// æ–‡ä»¶å†…å®¹å®‰å…¨æ£€æµ‹
func (s *minioStorageService) ScanFile(ctx context.Context, fileID string) (*ScanResult, error) {
    // 1. ç—…æ¯’æ‰«æ (å¯é›†æˆClamAV)
    // 2. æ•æ„Ÿå†…å®¹æ£€æµ‹ (å¯é›†æˆäº‘æœåŠ¡çš„å†…å®¹å®¡æ ¸API)
    return nil, nil
}
```

### 7.9 Docker Compose æ·»åŠ  MinIO

```yaml
# åœ¨ docker-compose.yml ä¸­æ·»åŠ 
services:
  # ... å…¶ä»–æœåŠ¡
  
  minio:
    image: minio/minio:latest
    ports:
      - "9000:9000"   # APIç«¯å£
      - "9001:9001"   # æ§åˆ¶å°ç«¯å£
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin123
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

volumes:
  minio_data:
```

---

## ä¹ã€è·¨èŠ‚ç‚¹æ¶ˆæ¯è·¯ç”±

### 5.1 æ¶ˆæ¯åˆ†å‘å™¨

```go
// message_dispatcher.go

package gateway

import (
    "context"
    "encoding/json"
    "log"
    "sync"
    
    "github.com/go-redis/redis/v8"
)

// MessageDispatcher æ¶ˆæ¯åˆ†å‘å™¨æ¥å£
type MessageDispatcher interface {
    // åˆ†å‘æ¶ˆæ¯ç»™æŒ‡å®šç”¨æˆ·åˆ—è¡¨
    DispatchToUsers(ctx context.Context, msg *Message, userIDs []string) error
    
    // åˆ†å‘æ¶ˆæ¯ç»™ä¼šè¯ä¸­çš„ç”¨æˆ·
    DispatchToConversation(ctx context.Context, msg *Message, conversationID string, excludeUserID string) error
    
    // è®¢é˜…æœ¬èŠ‚ç‚¹çš„æ¶ˆæ¯
    SubscribeNodeMessages(ctx context.Context, nodeID string) error
}

type messageDispatcherImpl struct {
    nodeID       string
    redis        *redis.Client
    localConns   *sync.Map // userID -> *websocket.Conn
    connMutex    *sync.RWMutex
    groupService GroupService
}

func NewMessageDispatcher(
    nodeID string,
    redis *redis.Client,
    localConns *sync.Map,
    connMutex *sync.RWMutex,
    groupService GroupService,
) MessageDispatcher {
    return &messageDispatcherImpl{
        nodeID:       nodeID,
        redis:        redis,
        localConns:   localConns,
        connMutex:    connMutex,
        groupService: groupService,
    }
}

// DispatchToUsers åˆ†å‘æ¶ˆæ¯ç»™æŒ‡å®šç”¨æˆ·åˆ—è¡¨
func (d *messageDispatcherImpl) DispatchToUsers(ctx context.Context, msg *Message, userIDs []string) error {
    data, err := json.Marshal(msg)
    if err != nil {
        return err
    }
    
    // æŒ‰èŠ‚ç‚¹åˆ†ç»„
    nodeUsers := make(map[string][]string)
    localUsers := make([]string, 0)
    
    for _, userID := range userIDs {
        // æŸ¥è¯¢ç”¨æˆ·æ‰€åœ¨èŠ‚ç‚¹
        nodeKey := "online:" + userID
        nodeInfo, err := d.redis.Get(ctx, nodeKey).Result()
        
        if err == redis.Nil {
            // ç”¨æˆ·ç¦»çº¿ï¼Œå­˜å‚¨ç¦»çº¿æ¶ˆæ¯
            d.saveOfflineMessage(ctx, userID, msg)
            continue
        }
        
        // è§£æèŠ‚ç‚¹ä¿¡æ¯ "nodeID:timestamp"
        parts := strings.Split(nodeInfo, ":")
        if len(parts) < 1 {
            continue
        }
        targetNode := parts[0]
        
        if targetNode == d.nodeID {
            // æœ¬èŠ‚ç‚¹ç”¨æˆ·
            localUsers = append(localUsers, userID)
        } else {
            // å…¶ä»–èŠ‚ç‚¹ç”¨æˆ·
            nodeUsers[targetNode] = append(nodeUsers[targetNode], userID)
        }
    }
    
    // æ¨é€ç»™æœ¬èŠ‚ç‚¹ç”¨æˆ·
    for _, userID := range localUsers {
        d.pushToLocalUser(userID, data)
    }
    
    // é€šè¿‡Redis Pub/Subæ¨é€ç»™å…¶ä»–èŠ‚ç‚¹
    for targetNode, users := range nodeUsers {
        routeMsg := &RouteMessage{
            TargetUsers: users,
            Message:     data,
        }
        routeData, _ := json.Marshal(routeMsg)
        d.redis.Publish(ctx, "node:"+targetNode, routeData)
    }
    
    return nil
}

// DispatchToConversation åˆ†å‘æ¶ˆæ¯ç»™ä¼šè¯ä¸­çš„ç”¨æˆ·
func (d *messageDispatcherImpl) DispatchToConversation(ctx context.Context, msg *Message, conversationID string, excludeUserID string) error {
    var userIDs []string
    
    if strings.HasPrefix(conversationID, "group:") {
        // ç¾¤èŠä¼šè¯
        groupID := strings.TrimPrefix(conversationID, "group:")
        members, err := d.redis.SMembers(ctx, "group:members:"+groupID).Result()
        if err != nil {
            return err
        }
        userIDs = members
    } else {
        // å•èŠä¼šè¯ï¼Œè§£æä¼šè¯IDè·å–åŒæ–¹ç”¨æˆ·ID
        // ä¼šè¯IDæ ¼å¼: "user1:user2" (æŒ‰å­—å…¸åºæ’åº)
        parts := strings.Split(conversationID, ":")
        if len(parts) == 2 {
            userIDs = parts
        }
    }
    
    // æ’é™¤æŒ‡å®šç”¨æˆ·
    if excludeUserID != "" {
        filtered := make([]string, 0, len(userIDs))
        for _, uid := range userIDs {
            if uid != excludeUserID {
                filtered = append(filtered, uid)
            }
        }
        userIDs = filtered
    }
    
    return d.DispatchToUsers(ctx, msg, userIDs)
}

// pushToLocalUser æ¨é€ç»™æœ¬èŠ‚ç‚¹ç”¨æˆ·
func (d *messageDispatcherImpl) pushToLocalUser(userID string, data []byte) {
    if conn, ok := d.localConns.Load(userID); ok {
        if wsConn, ok := conn.(*websocket.Conn); ok {
            wsConn.WriteMessage(websocket.TextMessage, data)
        }
    }
}

// saveOfflineMessage ä¿å­˜ç¦»çº¿æ¶ˆæ¯
func (d *messageDispatcherImpl) saveOfflineMessage(ctx context.Context, userID string, msg *Message) {
    data, _ := json.Marshal(msg)
    key := "offline:" + userID
    d.redis.ZAdd(ctx, key, &redis.Z{
        Score:  float64(msg.Timestamp),
        Member: string(data),
    })
    d.redis.Expire(ctx, key, 7*24*time.Hour)
}

// SubscribeNodeMessages è®¢é˜…æœ¬èŠ‚ç‚¹çš„æ¶ˆæ¯
func (d *messageDispatcherImpl) SubscribeNodeMessages(ctx context.Context, nodeID string) error {
    pubsub := d.redis.Subscribe(ctx, "node:"+nodeID)
    defer pubsub.Close()
    
    ch := pubsub.Channel()
    
    for {
        select {
        case <-ctx.Done():
            return nil
        case redisMsg := <-ch:
            var routeMsg RouteMessage
            if err := json.Unmarshal([]byte(redisMsg.Payload), &routeMsg); err != nil {
                log.Printf("unmarshal route message error: %v", err)
                continue
            }
            
            // æ¨é€ç»™æœ¬èŠ‚ç‚¹çš„ç›®æ ‡ç”¨æˆ·
            for _, userID := range routeMsg.TargetUsers {
                d.pushToLocalUser(userID, routeMsg.Message)
            }
        }
    }
}

// RouteMessage è·¯ç”±æ¶ˆæ¯ç»“æ„
type RouteMessage struct {
    TargetUsers []string `json:"target_users"`
    Message     []byte   `json:"message"`
}
```

### 5.2 Gatewayå¯åŠ¨æ—¶è®¢é˜…

```go
// main.go (æ›´æ–°)

func main() {
    // ... åˆå§‹åŒ–ä»£ç 
    
    nodeID := os.Getenv("NODE_ID")
    if nodeID == "" {
        nodeID = uuid.New().String()
    }
    
    // åˆå§‹åŒ–æ¶ˆæ¯åˆ†å‘å™¨
    dispatcher := NewMessageDispatcher(nodeID, redisClient, &connections, &connMutex, groupService)
    
    // å¯åŠ¨æ¶ˆæ¯è®¢é˜…
    go dispatcher.SubscribeNodeMessages(context.Background(), nodeID)
    
    // ... HTTPæœåŠ¡å¯åŠ¨
}
```

---

## åã€å­˜å‚¨è®¾è®¡

### 6.1 MySQLè¡¨ç»“æ„

```sql
-- init.sql

-- ç”¨æˆ·è¡¨
CREATE TABLE IF NOT EXISTS users (
    user_id VARCHAR(64) PRIMARY KEY,
    username VARCHAR(64) NOT NULL UNIQUE,
    nickname VARCHAR(64),
    avatar VARCHAR(512),
    password_hash VARCHAR(256) NOT NULL,
    status TINYINT DEFAULT 1 COMMENT '1-æ­£å¸¸ 0-ç¦ç”¨',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ç¾¤ç»„è¡¨
CREATE TABLE IF NOT EXISTS groups (
    group_id VARCHAR(64) PRIMARY KEY,
    name VARCHAR(128) NOT NULL,
    avatar VARCHAR(512),
    announcement TEXT,
    description VARCHAR(512),
    owner_id VARCHAR(64) NOT NULL,
    max_members INT DEFAULT 500,
    member_count INT DEFAULT 0,
    mute_all BOOLEAN DEFAULT FALSE,
    join_mode TINYINT DEFAULT 0 COMMENT '0-è‡ªç”±åŠ å…¥ 1-éœ€å®¡æ‰¹ 2-ç¦æ­¢åŠ å…¥',
    status TINYINT DEFAULT 1 COMMENT '1-æ­£å¸¸ 0-å·²è§£æ•£',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_owner (owner_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ç¾¤æˆå‘˜è¡¨
CREATE TABLE IF NOT EXISTS group_members (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    group_id VARCHAR(64) NOT NULL,
    user_id VARCHAR(64) NOT NULL,
    role TINYINT DEFAULT 0 COMMENT '0-æˆå‘˜ 1-ç®¡ç†å‘˜ 2-ç¾¤ä¸»',
    nickname VARCHAR(64),
    mute_until BIGINT DEFAULT 0,
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    inviter_id VARCHAR(64),
    UNIQUE INDEX idx_group_user (group_id, user_id),
    INDEX idx_user (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- æ¶ˆæ¯è®°å½•è¡¨ï¼ˆæŒ‰æœˆåˆ†è¡¨ï¼‰
CREATE TABLE IF NOT EXISTS messages_202401 (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    message_id VARCHAR(64) NOT NULL UNIQUE,
    conversation_id VARCHAR(128) NOT NULL,
    type TINYINT NOT NULL,
    from_user_id VARCHAR(64) NOT NULL,
    to_id VARCHAR(64) NOT NULL,
    content TEXT,
    seq BIGINT NOT NULL,
    revoked BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_conversation_seq (conversation_id, seq),
    INDEX idx_from_user (from_user_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ç¦»çº¿æ¶ˆæ¯è¡¨
CREATE TABLE IF NOT EXISTS offline_messages (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(64) NOT NULL,
    message_id VARCHAR(64) NOT NULL UNIQUE,
    conversation_id VARCHAR(128) NOT NULL,
    content TEXT NOT NULL,
    pushed BOOLEAN DEFAULT FALSE,
    pushed_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expire_at TIMESTAMP NOT NULL,
    INDEX idx_user_created (user_id, created_at),
    INDEX idx_expire (expire_at),
    INDEX idx_pushed (pushed)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- è®¾å¤‡è¡¨ï¼ˆç”¨äºæ¨é€ï¼‰
CREATE TABLE IF NOT EXISTS devices (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(64) NOT NULL,
    device_token VARCHAR(256) NOT NULL UNIQUE,
    platform VARCHAR(16) NOT NULL COMMENT 'ios/android',
    app_version VARCHAR(32),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ä¼šè¯è¡¨
CREATE TABLE IF NOT EXISTS conversations (
    conversation_id VARCHAR(128) PRIMARY KEY,
    type TINYINT NOT NULL COMMENT '1-å•èŠ 2-ç¾¤èŠ',
    last_message_id VARCHAR(64),
    last_message_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ç”¨æˆ·ä¼šè¯å…³ç³»è¡¨
CREATE TABLE IF NOT EXISTS user_conversations (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(64) NOT NULL,
    conversation_id VARCHAR(128) NOT NULL,
    unread_count INT DEFAULT 0,
    last_read_seq BIGINT DEFAULT 0,
    muted BOOLEAN DEFAULT FALSE,
    pinned BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE INDEX idx_user_conv (user_id, conversation_id),
    INDEX idx_user_updated (user_id, updated_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 6.2 Redisæ•°æ®ç»“æ„æ±‡æ€»

```redis
# ==================== ç”¨æˆ·åœ¨çº¿çŠ¶æ€ ====================
# Key: online:{user_id}
# Value: {node_id}:{timestamp}
# TTL: 3600s (å¿ƒè·³ç»­æœŸ)
SETEX online:user_10001 3600 "node1:1704067200000"

# ==================== ç¾¤ç»„æˆå‘˜ ====================
# Key: group:members:{group_id}
# Type: SET
SADD group:members:group_001 user_10001 user_10002 user_10003

# ==================== ç¦»çº¿æ¶ˆæ¯ ====================
# Key: offline:{user_id}
# Type: SORTED SET (score=timestamp)
# TTL: 7å¤©
ZADD offline:user_10001 1704067200000 '{"message_id":"xxx","content":"hello"}'
EXPIRE offline:user_10001 604800

# ==================== å·²è¯»ä½ç½® ====================
# Key: read:{conversation_id}
# Type: HASH
# Field: user_id, Value: last_read_seq
HSET read:group:group_001 user_10001 100
HSET read:group:group_001 user_10002 98

# ==================== æ¶ˆæ¯åºåˆ—å· ====================
# Key: seq:{conversation_id}
# Type: STRING (è‡ªå¢)
INCR seq:group:group_001

# ==================== æ¶ˆæ¯å»é‡ ====================
# Key: dedup:{message_id}
# TTL: 5åˆ†é’Ÿ
SETEX dedup:msg_uuid_xxx 300 1

# ==================== è·¨èŠ‚ç‚¹æ¶ˆæ¯é€šé“ ====================
# Channel: node:{node_id}
# ç”¨äºRedis Pub/Sub
PUBLISH node:node1 '{"target_users":["user_10001"],"message":{...}}'
```

---

## åä¸€ã€å®Œæ•´é¡¹ç›®ç»“æ„

```
im-system/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ gateway/              # æ¥å…¥å±‚æœåŠ¡
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â””â”€â”€ push/                 # æ¨é€æœåŠ¡
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ model/                # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ message.go
â”‚   â”‚   â”œâ”€â”€ group.go
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â”œâ”€â”€ device.go
â”‚   â”‚   â””â”€â”€ file_message.go   # æ–‡ä»¶æ¶ˆæ¯æ¨¡å‹
â”‚   â”œâ”€â”€ service/              # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ group_service.go
â”‚   â”‚   â”œâ”€â”€ offline_service.go
â”‚   â”‚   â”œâ”€â”€ push_service.go
â”‚   â”‚   â”œâ”€â”€ revoke_service.go
â”‚   â”‚   â”œâ”€â”€ read_receipt_service.go
â”‚   â”‚   â””â”€â”€ file_storage.go   # æ–‡ä»¶å­˜å‚¨æœåŠ¡
â”‚   â”œâ”€â”€ handler/              # HTTPå¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ group_handler.go
â”‚   â”‚   â”œâ”€â”€ offline_handler.go
â”‚   â”‚   â”œâ”€â”€ message_handler.go
â”‚   â”‚   â””â”€â”€ file_handler.go   # æ–‡ä»¶ä¸Šä¼ ä¸‹è½½API
â”‚   â”œâ”€â”€ gateway/              # ç½‘å…³æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ connection.go
â”‚   â”‚   â”œâ”€â”€ dispatcher.go
â”‚   â”‚   â””â”€â”€ handler.go
â”‚   â””â”€â”€ repository/           # æ•°æ®è®¿é—®
â”‚       â”œâ”€â”€ group_repo.go
â”‚       â”œâ”€â”€ message_repo.go
â”‚       â””â”€â”€ device_repo.go
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ auth/                 # è®¤è¯
â”‚   â”‚   â””â”€â”€ jwt.go
â”‚   â”œâ”€â”€ util/                 # å·¥å…·
â”‚   â”‚   â””â”€â”€ id.go
â”‚   â””â”€â”€ proto/                # Protobufå®šä¹‰
â”‚       â””â”€â”€ message.proto
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ init.sql              # æ•°æ®åº“åˆå§‹åŒ–
â”‚   â””â”€â”€ stress_test.py        # å‹æµ‹è„šæœ¬
â”œâ”€â”€ deploy/
â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â””â”€â”€ k8s/
â”‚       â”œâ”€â”€ gateway.yaml
â”‚       â””â”€â”€ push.yaml
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.yaml           # é…ç½®æ–‡ä»¶
â”œâ”€â”€ web/                      # å‰ç«¯ç¤ºä¾‹
â”‚   â””â”€â”€ chat.html
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â””â”€â”€ README.md
```

---

## åäºŒã€åŠŸèƒ½å¯¹æ¯”æ€»ç»“

| åŠŸèƒ½ | åŸæ–¹æ¡ˆ | è¡¥å……å |
|------|--------|--------|
| å•èŠæ¶ˆæ¯ | âœ… | âœ… |
| ç¾¤èŠæ¶ˆæ¯ | âœ… åŸºç¡€ | âœ… å®Œæ•´ |
| å¿ƒè·³ä¿æ´» | âœ… | âœ… |
| æ¶ˆæ¯å»é‡ | âœ… | âœ… |
| **ç¾¤æˆå‘˜åŠ å…¥é€šçŸ¥** | âŒ | âœ… |
| **ç¾¤æˆå‘˜é€€å‡ºé€šçŸ¥** | âŒ | âœ… |
| **ç¾¤æˆå‘˜è¢«è¸¢é€šçŸ¥** | âŒ | âœ… |
| **ç¾¤èµ„æ–™ç®¡ç†** | âŒ | âœ… |
| **ç¾¤ç®¡ç†å‘˜æƒé™** | âŒ | âœ… |
| **ç¦»çº¿æ¶ˆæ¯å­˜å‚¨** | âœ… ç®€å• | âœ… å®Œæ•´ |
| **ç¦»çº¿æ¶ˆæ¯æ‹‰å–** | âŒ | âœ… |
| **APNs/FCMæ¨é€** | âŒ | âœ… |
| **æ¶ˆæ¯å·²è¯»å›æ‰§** | âŒ | âœ… |
| **æ¶ˆæ¯æ’¤å›** | âŒ | âœ… |
| **æ¶ˆæ¯ACKç¡®è®¤** | âŒ | âœ… |
| **è·¨èŠ‚ç‚¹è·¯ç”±** | âŒ ä»…æ³¨é‡Š | âœ… å®Œæ•´å®ç° |
| **æ•°æ®åº“è¡¨è®¾è®¡** | âŒ | âœ… |
| **å›¾ç‰‡æ¶ˆæ¯** | âŒ | âœ… |
| **æ–‡ä»¶æ¶ˆæ¯** | âŒ | âœ… |
| **åˆ†ç‰‡ä¸Šä¼ ** | âŒ | âœ… |
| **æ–‡ä»¶å­˜å‚¨(MinIO/OSS)** | âŒ | âœ… |
| é…ç½®ç®¡ç† | âŒ ç¡¬ç¼–ç  | âœ… é…ç½®æ–‡ä»¶ |

---

## åä¸‰ã€ä¸‹ä¸€æ­¥å»ºè®®

1. **å®‰å…¨å¢å¼º**
   - å®ç°å®Œæ•´çš„JWTè®¤è¯
   - æ·»åŠ æ¶ˆæ¯å†…å®¹åŠ å¯†ï¼ˆç«¯åˆ°ç«¯åŠ å¯†ï¼‰
   - å¢åŠ é¢‘ç‡é™åˆ¶å’Œé˜²åˆ·æœºåˆ¶

2. **å¯è§‚æµ‹æ€§**
   - é›†æˆOpenTelemetryé“¾è·¯è¿½è¸ª
   - å®Œå–„PrometheusæŒ‡æ ‡
   - æ·»åŠ ç»“æ„åŒ–æ—¥å¿—

3. **é«˜å¯ç”¨**
   - Redis Sentinel/Cluster
   - MySQLä¸»ä»å¤åˆ¶
   - å¤šæœºæˆ¿éƒ¨ç½²æ–¹æ¡ˆ

4. **æ€§èƒ½ä¼˜åŒ–**
   - æ¶ˆæ¯è¡¨åˆ†åº“åˆ†è¡¨
   - çƒ­ç‚¹ç¾¤ç»„ç¼“å­˜ç­–ç•¥
   - è¿æ¥æ± ä¼˜åŒ–

å¦‚éœ€è¿›ä¸€æ­¥ç»†åŒ–æŸä¸ªæ¨¡å—çš„å®ç°ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼

---

## é™„å½•ï¼šå‚è€ƒèµ„æ–™

### å¼€æºé¡¹ç›®æ–‡æ¡£
- OpenIMå®˜æ–¹æ–‡æ¡£: https://docs.openim.io
- WuKongIMå®˜æ–¹æ–‡æ¡£: https://docs.githubim.com
- Rocket.Chatå¼€å‘æ–‡æ¡£: https://developer.rocket.chat

### åè®®è§„èŒƒ
- WebSocketåè®® (RFC 6455): https://tools.ietf.org/html/rfc6455
- Server-Sent Events: https://html.spec.whatwg.org/multipage/server-sent-events.html
- JSON-RPC 2.0: https://www.jsonrpc.org/specification

### æ¨é€æœåŠ¡
- Apple APNs: https://developer.apple.com/documentation/usernotifications
- Firebase Cloud Messaging: https://firebase.google.com/docs/cloud-messaging